export const dummyDbSchema = {
  functionSignatures: {
    abs: {
      label: 'abs',
    },
    acos: {
      label: 'acos',
    },
    all: {
      label: 'all',
    },
    any: {
      label: 'any',
    },
    'apoc.agg.first': {
      label: 'apoc.agg.first',
    },
    'apoc.agg.graph': {
      label: 'apoc.agg.graph',
    },
    'apoc.agg.last': {
      label: 'apoc.agg.last',
    },
    'apoc.agg.maxItems': {
      label: 'apoc.agg.maxItems',
    },
    'apoc.agg.median': {
      label: 'apoc.agg.median',
    },
    'apoc.agg.minItems': {
      label: 'apoc.agg.minItems',
    },
    'apoc.agg.nth': {
      label: 'apoc.agg.nth',
    },
    'apoc.agg.percentiles': {
      label: 'apoc.agg.percentiles',
    },
    'apoc.agg.product': {
      label: 'apoc.agg.product',
    },
    'apoc.agg.slice': {
      label: 'apoc.agg.slice',
    },
    'apoc.agg.statistics': {
      label: 'apoc.agg.statistics',
    },
    'apoc.any.isDeleted': {
      label: 'apoc.any.isDeleted',
    },
    'apoc.any.properties': {
      label: 'apoc.any.properties',
    },
    'apoc.any.property': {
      label: 'apoc.any.property',
    },
    'apoc.any.rebind': {
      label: 'apoc.any.rebind',
    },
    'apoc.bitwise.op': {
      label: 'apoc.bitwise.op',
    },
    'apoc.coll.avg': {
      label: 'apoc.coll.avg',
    },
    'apoc.coll.avgDuration': {
      label: 'apoc.coll.avgDuration',
    },
    'apoc.coll.combinations': {
      label: 'apoc.coll.combinations',
    },
    'apoc.coll.contains': {
      label: 'apoc.coll.contains',
    },
    'apoc.coll.containsAll': {
      label: 'apoc.coll.containsAll',
    },
    'apoc.coll.containsAllSorted': {
      label: 'apoc.coll.containsAllSorted',
    },
    'apoc.coll.containsDuplicates': {
      label: 'apoc.coll.containsDuplicates',
    },
    'apoc.coll.containsSorted': {
      label: 'apoc.coll.containsSorted',
    },
    'apoc.coll.different': {
      label: 'apoc.coll.different',
    },
    'apoc.coll.disjunction': {
      label: 'apoc.coll.disjunction',
    },
    'apoc.coll.dropDuplicateNeighbors': {
      label: 'apoc.coll.dropDuplicateNeighbors',
    },
    'apoc.coll.duplicates': {
      label: 'apoc.coll.duplicates',
    },
    'apoc.coll.duplicatesWithCount': {
      label: 'apoc.coll.duplicatesWithCount',
    },
    'apoc.coll.fill': {
      label: 'apoc.coll.fill',
    },
    'apoc.coll.flatten': {
      label: 'apoc.coll.flatten',
    },
    'apoc.coll.frequencies': {
      label: 'apoc.coll.frequencies',
    },
    'apoc.coll.frequenciesAsMap': {
      label: 'apoc.coll.frequenciesAsMap',
    },
    'apoc.coll.indexOf': {
      label: 'apoc.coll.indexOf',
    },
    'apoc.coll.insert': {
      label: 'apoc.coll.insert',
    },
    'apoc.coll.insertAll': {
      label: 'apoc.coll.insertAll',
    },
    'apoc.coll.intersection': {
      label: 'apoc.coll.intersection',
    },
    'apoc.coll.isEqualCollection': {
      label: 'apoc.coll.isEqualCollection',
    },
    'apoc.coll.max': {
      label: 'apoc.coll.max',
    },
    'apoc.coll.min': {
      label: 'apoc.coll.min',
    },
    'apoc.coll.occurrences': {
      label: 'apoc.coll.occurrences',
    },
    'apoc.coll.pairWithOffset': {
      label: 'apoc.coll.pairWithOffset',
    },
    'apoc.coll.pairs': {
      label: 'apoc.coll.pairs',
    },
    'apoc.coll.pairsMin': {
      label: 'apoc.coll.pairsMin',
    },
    'apoc.coll.partition': {
      label: 'apoc.coll.partition',
    },
    'apoc.coll.randomItem': {
      label: 'apoc.coll.randomItem',
    },
    'apoc.coll.randomItems': {
      label: 'apoc.coll.randomItems',
    },
    'apoc.coll.remove': {
      label: 'apoc.coll.remove',
    },
    'apoc.coll.removeAll': {
      label: 'apoc.coll.removeAll',
    },
    'apoc.coll.reverse': {
      label: 'apoc.coll.reverse',
    },
    'apoc.coll.runningTotal': {
      label: 'apoc.coll.runningTotal',
    },
    'apoc.coll.set': {
      label: 'apoc.coll.set',
    },
    'apoc.coll.shuffle': {
      label: 'apoc.coll.shuffle',
    },
    'apoc.coll.sort': {
      label: 'apoc.coll.sort',
    },
    'apoc.coll.sortMaps': {
      label: 'apoc.coll.sortMaps',
    },
    'apoc.coll.sortMulti': {
      label: 'apoc.coll.sortMulti',
    },
    'apoc.coll.sortNodes': {
      label: 'apoc.coll.sortNodes',
    },
    'apoc.coll.sortText': {
      label: 'apoc.coll.sortText',
    },
    'apoc.coll.stdev': {
      label: 'apoc.coll.stdev',
    },
    'apoc.coll.subtract': {
      label: 'apoc.coll.subtract',
    },
    'apoc.coll.sum': {
      label: 'apoc.coll.sum',
    },
    'apoc.coll.sumLongs': {
      label: 'apoc.coll.sumLongs',
    },
    'apoc.coll.toSet': {
      label: 'apoc.coll.toSet',
    },
    'apoc.coll.union': {
      label: 'apoc.coll.union',
    },
    'apoc.coll.unionAll': {
      label: 'apoc.coll.unionAll',
    },
    'apoc.coll.zip': {
      label: 'apoc.coll.zip',
    },
    'apoc.convert.fromJsonList': {
      label: 'apoc.convert.fromJsonList',
    },
    'apoc.convert.fromJsonMap': {
      label: 'apoc.convert.fromJsonMap',
    },
    'apoc.convert.getJsonProperty': {
      label: 'apoc.convert.getJsonProperty',
    },
    'apoc.convert.getJsonPropertyMap': {
      label: 'apoc.convert.getJsonPropertyMap',
    },
    'apoc.convert.toBoolean': {
      label: 'apoc.convert.toBoolean',
    },
    'apoc.convert.toBooleanList': {
      label: 'apoc.convert.toBooleanList',
    },
    'apoc.convert.toFloat': {
      label: 'apoc.convert.toFloat',
    },
    'apoc.convert.toIntList': {
      label: 'apoc.convert.toIntList',
    },
    'apoc.convert.toInteger': {
      label: 'apoc.convert.toInteger',
    },
    'apoc.convert.toJson': {
      label: 'apoc.convert.toJson',
    },
    'apoc.convert.toList': {
      label: 'apoc.convert.toList',
    },
    'apoc.convert.toMap': {
      label: 'apoc.convert.toMap',
    },
    'apoc.convert.toNode': {
      label: 'apoc.convert.toNode',
    },
    'apoc.convert.toNodeList': {
      label: 'apoc.convert.toNodeList',
    },
    'apoc.convert.toRelationship': {
      label: 'apoc.convert.toRelationship',
    },
    'apoc.convert.toRelationshipList': {
      label: 'apoc.convert.toRelationshipList',
    },
    'apoc.convert.toSet': {
      label: 'apoc.convert.toSet',
    },
    'apoc.convert.toSortedJsonMap': {
      label: 'apoc.convert.toSortedJsonMap',
    },
    'apoc.convert.toString': {
      label: 'apoc.convert.toString',
    },
    'apoc.convert.toStringList': {
      label: 'apoc.convert.toStringList',
    },
    'apoc.create.uuid': {
      label: 'apoc.create.uuid',
    },
    'apoc.create.uuidBase64': {
      label: 'apoc.create.uuidBase64',
    },
    'apoc.create.uuidBase64ToHex': {
      label: 'apoc.create.uuidBase64ToHex',
    },
    'apoc.create.uuidHexToBase64': {
      label: 'apoc.create.uuidHexToBase64',
    },
    'apoc.create.vNode': {
      label: 'apoc.create.vNode',
    },
    'apoc.create.vRelationship': {
      label: 'apoc.create.vRelationship',
    },
    'apoc.create.virtual.fromNode': {
      label: 'apoc.create.virtual.fromNode',
    },
    'apoc.cypher.runFirstColumn': {
      label: 'apoc.cypher.runFirstColumn',
    },
    'apoc.cypher.runFirstColumnMany': {
      label: 'apoc.cypher.runFirstColumnMany',
    },
    'apoc.cypher.runFirstColumnSingle': {
      label: 'apoc.cypher.runFirstColumnSingle',
    },
    'apoc.data.domain': {
      label: 'apoc.data.domain',
    },
    'apoc.data.url': {
      label: 'apoc.data.url',
    },
    'apoc.date.add': {
      label: 'apoc.date.add',
    },
    'apoc.date.convert': {
      label: 'apoc.date.convert',
    },
    'apoc.date.convertFormat': {
      label: 'apoc.date.convertFormat',
    },
    'apoc.date.currentTimestamp': {
      label: 'apoc.date.currentTimestamp',
    },
    'apoc.date.field': {
      label: 'apoc.date.field',
    },
    'apoc.date.fields': {
      label: 'apoc.date.fields',
    },
    'apoc.date.format': {
      label: 'apoc.date.format',
    },
    'apoc.date.fromISO8601': {
      label: 'apoc.date.fromISO8601',
    },
    'apoc.date.parse': {
      label: 'apoc.date.parse',
    },
    'apoc.date.parseAsZonedDateTime': {
      label: 'apoc.date.parseAsZonedDateTime',
    },
    'apoc.date.systemTimezone': {
      label: 'apoc.date.systemTimezone',
    },
    'apoc.date.toISO8601': {
      label: 'apoc.date.toISO8601',
    },
    'apoc.date.toYears': {
      label: 'apoc.date.toYears',
    },
    'apoc.diff.nodes': {
      label: 'apoc.diff.nodes',
    },
    'apoc.hashing.fingerprint': {
      label: 'apoc.hashing.fingerprint',
    },
    'apoc.hashing.fingerprintGraph': {
      label: 'apoc.hashing.fingerprintGraph',
    },
    'apoc.hashing.fingerprinting': {
      label: 'apoc.hashing.fingerprinting',
    },
    'apoc.json.path': {
      label: 'apoc.json.path',
    },
    'apoc.label.exists': {
      label: 'apoc.label.exists',
    },
    'apoc.map.clean': {
      label: 'apoc.map.clean',
    },
    'apoc.map.flatten': {
      label: 'apoc.map.flatten',
    },
    'apoc.map.fromLists': {
      label: 'apoc.map.fromLists',
    },
    'apoc.map.fromNodes': {
      label: 'apoc.map.fromNodes',
    },
    'apoc.map.fromPairs': {
      label: 'apoc.map.fromPairs',
    },
    'apoc.map.fromValues': {
      label: 'apoc.map.fromValues',
    },
    'apoc.map.get': {
      label: 'apoc.map.get',
    },
    'apoc.map.groupBy': {
      label: 'apoc.map.groupBy',
    },
    'apoc.map.groupByMulti': {
      label: 'apoc.map.groupByMulti',
    },
    'apoc.map.merge': {
      label: 'apoc.map.merge',
    },
    'apoc.map.mergeList': {
      label: 'apoc.map.mergeList',
    },
    'apoc.map.mget': {
      label: 'apoc.map.mget',
    },
    'apoc.map.removeKey': {
      label: 'apoc.map.removeKey',
    },
    'apoc.map.removeKeys': {
      label: 'apoc.map.removeKeys',
    },
    'apoc.map.setEntry': {
      label: 'apoc.map.setEntry',
    },
    'apoc.map.setKey': {
      label: 'apoc.map.setKey',
    },
    'apoc.map.setLists': {
      label: 'apoc.map.setLists',
    },
    'apoc.map.setPairs': {
      label: 'apoc.map.setPairs',
    },
    'apoc.map.setValues': {
      label: 'apoc.map.setValues',
    },
    'apoc.map.sortedProperties': {
      label: 'apoc.map.sortedProperties',
    },
    'apoc.map.submap': {
      label: 'apoc.map.submap',
    },
    'apoc.map.unflatten': {
      label: 'apoc.map.unflatten',
    },
    'apoc.map.updateTree': {
      label: 'apoc.map.updateTree',
    },
    'apoc.map.values': {
      label: 'apoc.map.values',
    },
    'apoc.math.cosh': {
      label: 'apoc.math.cosh',
    },
    'apoc.math.coth': {
      label: 'apoc.math.coth',
    },
    'apoc.math.csch': {
      label: 'apoc.math.csch',
    },
    'apoc.math.maxByte': {
      label: 'apoc.math.maxByte',
    },
    'apoc.math.maxDouble': {
      label: 'apoc.math.maxDouble',
    },
    'apoc.math.maxInt': {
      label: 'apoc.math.maxInt',
    },
    'apoc.math.maxLong': {
      label: 'apoc.math.maxLong',
    },
    'apoc.math.minByte': {
      label: 'apoc.math.minByte',
    },
    'apoc.math.minDouble': {
      label: 'apoc.math.minDouble',
    },
    'apoc.math.minInt': {
      label: 'apoc.math.minInt',
    },
    'apoc.math.minLong': {
      label: 'apoc.math.minLong',
    },
    'apoc.math.round': {
      label: 'apoc.math.round',
    },
    'apoc.math.sech': {
      label: 'apoc.math.sech',
    },
    'apoc.math.sigmoid': {
      label: 'apoc.math.sigmoid',
    },
    'apoc.math.sigmoidPrime': {
      label: 'apoc.math.sigmoidPrime',
    },
    'apoc.math.sinh': {
      label: 'apoc.math.sinh',
    },
    'apoc.math.tanh': {
      label: 'apoc.math.tanh',
    },
    'apoc.meta.cypher.isType': {
      label: 'apoc.meta.cypher.isType',
    },
    'apoc.meta.cypher.type': {
      label: 'apoc.meta.cypher.type',
    },
    'apoc.meta.cypher.types': {
      label: 'apoc.meta.cypher.types',
    },
    'apoc.meta.isType': {
      label: 'apoc.meta.isType',
    },
    'apoc.meta.nodes.count': {
      label: 'apoc.meta.nodes.count',
    },
    'apoc.meta.type': {
      label: 'apoc.meta.type',
    },
    'apoc.meta.typeName': {
      label: 'apoc.meta.typeName',
    },
    'apoc.meta.types': {
      label: 'apoc.meta.types',
    },
    'apoc.node.degree': {
      label: 'apoc.node.degree',
    },
    'apoc.node.degree.in': {
      label: 'apoc.node.degree.in',
    },
    'apoc.node.degree.out': {
      label: 'apoc.node.degree.out',
    },
    'apoc.node.id': {
      label: 'apoc.node.id',
    },
    'apoc.node.labels': {
      label: 'apoc.node.labels',
    },
    'apoc.node.rebind': {
      label: 'apoc.node.rebind',
    },
    'apoc.node.relationship.exists': {
      label: 'apoc.node.relationship.exists',
    },
    'apoc.node.relationship.types': {
      label: 'apoc.node.relationship.types',
    },
    'apoc.node.relationships.exist': {
      label: 'apoc.node.relationships.exist',
    },
    'apoc.nodes.connected': {
      label: 'apoc.nodes.connected',
    },
    'apoc.nodes.isDense': {
      label: 'apoc.nodes.isDense',
    },
    'apoc.nodes.relationship.types': {
      label: 'apoc.nodes.relationship.types',
    },
    'apoc.nodes.relationships.exist': {
      label: 'apoc.nodes.relationships.exist',
    },
    'apoc.number.arabicToRoman': {
      label: 'apoc.number.arabicToRoman',
    },
    'apoc.number.exact.add': {
      label: 'apoc.number.exact.add',
    },
    'apoc.number.exact.div': {
      label: 'apoc.number.exact.div',
    },
    'apoc.number.exact.mul': {
      label: 'apoc.number.exact.mul',
    },
    'apoc.number.exact.sub': {
      label: 'apoc.number.exact.sub',
    },
    'apoc.number.exact.toExact': {
      label: 'apoc.number.exact.toExact',
    },
    'apoc.number.exact.toFloat': {
      label: 'apoc.number.exact.toFloat',
    },
    'apoc.number.exact.toInteger': {
      label: 'apoc.number.exact.toInteger',
    },
    'apoc.number.format': {
      label: 'apoc.number.format',
    },
    'apoc.number.parseFloat': {
      label: 'apoc.number.parseFloat',
    },
    'apoc.number.parseInt': {
      label: 'apoc.number.parseInt',
    },
    'apoc.number.romanToArabic': {
      label: 'apoc.number.romanToArabic',
    },
    'apoc.path.combine': {
      label: 'apoc.path.combine',
    },
    'apoc.path.create': {
      label: 'apoc.path.create',
    },
    'apoc.path.elements': {
      label: 'apoc.path.elements',
    },
    'apoc.path.slice': {
      label: 'apoc.path.slice',
    },
    'apoc.rel.endNode': {
      label: 'apoc.rel.endNode',
    },
    'apoc.rel.id': {
      label: 'apoc.rel.id',
    },
    'apoc.rel.rebind': {
      label: 'apoc.rel.rebind',
    },
    'apoc.rel.startNode': {
      label: 'apoc.rel.startNode',
    },
    'apoc.rel.type': {
      label: 'apoc.rel.type',
    },
    'apoc.schema.node.constraintExists': {
      label: 'apoc.schema.node.constraintExists',
    },
    'apoc.schema.node.indexExists': {
      label: 'apoc.schema.node.indexExists',
    },
    'apoc.schema.relationship.constraintExists': {
      label: 'apoc.schema.relationship.constraintExists',
    },
    'apoc.schema.relationship.indexExists': {
      label: 'apoc.schema.relationship.indexExists',
    },
    'apoc.scoring.existence': {
      label: 'apoc.scoring.existence',
    },
    'apoc.scoring.pareto': {
      label: 'apoc.scoring.pareto',
    },
    'apoc.static.get': {
      label: 'apoc.static.get',
    },
    'apoc.static.getAll': {
      label: 'apoc.static.getAll',
    },
    'apoc.temporal.format': {
      label: 'apoc.temporal.format',
    },
    'apoc.temporal.formatDuration': {
      label: 'apoc.temporal.formatDuration',
    },
    'apoc.temporal.toZonedTemporal': {
      label: 'apoc.temporal.toZonedTemporal',
    },
    'apoc.text.base64Decode': {
      label: 'apoc.text.base64Decode',
    },
    'apoc.text.base64Encode': {
      label: 'apoc.text.base64Encode',
    },
    'apoc.text.base64UrlDecode': {
      label: 'apoc.text.base64UrlDecode',
    },
    'apoc.text.base64UrlEncode': {
      label: 'apoc.text.base64UrlEncode',
    },
    'apoc.text.byteCount': {
      label: 'apoc.text.byteCount',
    },
    'apoc.text.bytes': {
      label: 'apoc.text.bytes',
    },
    'apoc.text.camelCase': {
      label: 'apoc.text.camelCase',
    },
    'apoc.text.capitalize': {
      label: 'apoc.text.capitalize',
    },
    'apoc.text.capitalizeAll': {
      label: 'apoc.text.capitalizeAll',
    },
    'apoc.text.charAt': {
      label: 'apoc.text.charAt',
    },
    'apoc.text.clean': {
      label: 'apoc.text.clean',
    },
    'apoc.text.code': {
      label: 'apoc.text.code',
    },
    'apoc.text.compareCleaned': {
      label: 'apoc.text.compareCleaned',
    },
    'apoc.text.decapitalize': {
      label: 'apoc.text.decapitalize',
    },
    'apoc.text.decapitalizeAll': {
      label: 'apoc.text.decapitalizeAll',
    },
    'apoc.text.distance': {
      label: 'apoc.text.distance',
    },
    'apoc.text.doubleMetaphone': {
      label: 'apoc.text.doubleMetaphone',
    },
    'apoc.text.format': {
      label: 'apoc.text.format',
    },
    'apoc.text.fuzzyMatch': {
      label: 'apoc.text.fuzzyMatch',
    },
    'apoc.text.hammingDistance': {
      label: 'apoc.text.hammingDistance',
    },
    'apoc.text.hexCharAt': {
      label: 'apoc.text.hexCharAt',
    },
    'apoc.text.hexValue': {
      label: 'apoc.text.hexValue',
    },
    'apoc.text.indexOf': {
      label: 'apoc.text.indexOf',
    },
    'apoc.text.indexesOf': {
      label: 'apoc.text.indexesOf',
    },
    'apoc.text.jaroWinklerDistance': {
      label: 'apoc.text.jaroWinklerDistance',
    },
    'apoc.text.join': {
      label: 'apoc.text.join',
    },
    'apoc.text.levenshteinDistance': {
      label: 'apoc.text.levenshteinDistance',
    },
    'apoc.text.levenshteinSimilarity': {
      label: 'apoc.text.levenshteinSimilarity',
    },
    'apoc.text.lpad': {
      label: 'apoc.text.lpad',
    },
    'apoc.text.phonetic': {
      label: 'apoc.text.phonetic',
    },
    'apoc.text.random': {
      label: 'apoc.text.random',
    },
    'apoc.text.regexGroups': {
      label: 'apoc.text.regexGroups',
    },
    'apoc.text.regreplace': {
      label: 'apoc.text.regreplace',
    },
    'apoc.text.repeat': {
      label: 'apoc.text.repeat',
    },
    'apoc.text.replace': {
      label: 'apoc.text.replace',
    },
    'apoc.text.rpad': {
      label: 'apoc.text.rpad',
    },
    'apoc.text.slug': {
      label: 'apoc.text.slug',
    },
    'apoc.text.snakeCase': {
      label: 'apoc.text.snakeCase',
    },
    'apoc.text.sorensenDiceSimilarity': {
      label: 'apoc.text.sorensenDiceSimilarity',
    },
    'apoc.text.split': {
      label: 'apoc.text.split',
    },
    'apoc.text.swapCase': {
      label: 'apoc.text.swapCase',
    },
    'apoc.text.toCypher': {
      label: 'apoc.text.toCypher',
    },
    'apoc.text.toUpperCase': {
      label: 'apoc.text.toUpperCase',
    },
    'apoc.text.upperCamelCase': {
      label: 'apoc.text.upperCamelCase',
    },
    'apoc.text.urldecode': {
      label: 'apoc.text.urldecode',
    },
    'apoc.text.urlencode': {
      label: 'apoc.text.urlencode',
    },
    'apoc.trigger.nodesByLabel': {
      label: 'apoc.trigger.nodesByLabel',
    },
    'apoc.trigger.propertiesByKey': {
      label: 'apoc.trigger.propertiesByKey',
    },
    'apoc.trigger.toNode': {
      label: 'apoc.trigger.toNode',
    },
    'apoc.trigger.toRelationship': {
      label: 'apoc.trigger.toRelationship',
    },
    'apoc.ttl.config': {
      label: 'apoc.ttl.config',
    },
    'apoc.util.compress': {
      label: 'apoc.util.compress',
    },
    'apoc.util.decompress': {
      label: 'apoc.util.decompress',
    },
    'apoc.util.md5': {
      label: 'apoc.util.md5',
    },
    'apoc.util.sha1': {
      label: 'apoc.util.sha1',
    },
    'apoc.util.sha256': {
      label: 'apoc.util.sha256',
    },
    'apoc.util.sha384': {
      label: 'apoc.util.sha384',
    },
    'apoc.util.sha512': {
      label: 'apoc.util.sha512',
    },
    'apoc.util.validatePredicate': {
      label: 'apoc.util.validatePredicate',
    },
    'apoc.version': {
      label: 'apoc.version',
    },
    'apoc.xml.parse': {
      label: 'apoc.xml.parse',
    },
    asin: {
      label: 'asin',
    },
    atan: {
      label: 'atan',
    },
    atan2: {
      label: 'atan2',
    },
    avg: {
      label: 'avg',
    },
    ceil: {
      label: 'ceil',
    },
    coalesce: {
      label: 'coalesce',
    },
    collect: {
      label: 'collect',
    },
    cos: {
      label: 'cos',
    },
    cot: {
      label: 'cot',
    },
    count: {
      label: 'count',
    },
    date: {
      label: 'date',
    },
    'date.realtime': {
      label: 'date.realtime',
    },
    'date.statement': {
      label: 'date.statement',
    },
    'date.transaction': {
      label: 'date.transaction',
    },
    'date.truncate': {
      label: 'date.truncate',
    },
    datetime: {
      label: 'datetime',
    },
    'datetime.fromepoch': {
      label: 'datetime.fromepoch',
    },
    'datetime.fromepochmillis': {
      label: 'datetime.fromepochmillis',
    },
    'datetime.realtime': {
      label: 'datetime.realtime',
    },
    'datetime.statement': {
      label: 'datetime.statement',
    },
    'datetime.transaction': {
      label: 'datetime.transaction',
    },
    'datetime.truncate': {
      label: 'datetime.truncate',
    },
    degrees: {
      label: 'degrees',
    },
    duration: {
      label: 'duration',
    },
    'duration.between': {
      label: 'duration.between',
    },
    'duration.inDays': {
      label: 'duration.inDays',
    },
    'duration.inMonths': {
      label: 'duration.inMonths',
    },
    'duration.inSeconds': {
      label: 'duration.inSeconds',
    },
    e: {
      label: 'e',
    },
    endNode: {
      label: 'endNode',
    },
    exists: {
      label: 'exists',
    },
    exp: {
      label: 'exp',
    },
    file: {
      label: 'file',
    },
    floor: {
      label: 'floor',
    },
    'gds.alpha.linkprediction.adamicAdar': {
      label: 'gds.alpha.linkprediction.adamicAdar',
    },
    'gds.alpha.linkprediction.commonNeighbors': {
      label: 'gds.alpha.linkprediction.commonNeighbors',
    },
    'gds.alpha.linkprediction.preferentialAttachment': {
      label: 'gds.alpha.linkprediction.preferentialAttachment',
    },
    'gds.alpha.linkprediction.resourceAllocation': {
      label: 'gds.alpha.linkprediction.resourceAllocation',
    },
    'gds.alpha.linkprediction.sameCommunity': {
      label: 'gds.alpha.linkprediction.sameCommunity',
    },
    'gds.alpha.linkprediction.totalNeighbors': {
      label: 'gds.alpha.linkprediction.totalNeighbors',
    },
    'gds.alpha.ml.oneHotEncoding': {
      label: 'gds.alpha.ml.oneHotEncoding',
    },
    'gds.graph.exists': {
      label: 'gds.graph.exists',
    },
    'gds.graph.project': {
      label: 'gds.graph.project',
    },
    'gds.similarity.cosine': {
      label: 'gds.similarity.cosine',
    },
    'gds.similarity.euclidean': {
      label: 'gds.similarity.euclidean',
    },
    'gds.similarity.euclideanDistance': {
      label: 'gds.similarity.euclideanDistance',
    },
    'gds.similarity.jaccard': {
      label: 'gds.similarity.jaccard',
    },
    'gds.similarity.overlap': {
      label: 'gds.similarity.overlap',
    },
    'gds.similarity.pearson': {
      label: 'gds.similarity.pearson',
    },
    'gds.util.NaN': {
      label: 'gds.util.NaN',
    },
    'gds.util.asNode': {
      label: 'gds.util.asNode',
    },
    'gds.util.asNodes': {
      label: 'gds.util.asNodes',
    },
    'gds.util.infinity': {
      label: 'gds.util.infinity',
    },
    'gds.util.isFinite': {
      label: 'gds.util.isFinite',
    },
    'gds.util.isInfinite': {
      label: 'gds.util.isInfinite',
    },
    'gds.util.nodeProperty': {
      label: 'gds.util.nodeProperty',
    },
    'gds.version': {
      label: 'gds.version',
    },
    haversin: {
      label: 'haversin',
    },
    head: {
      label: 'head',
    },
    id: {
      label: 'id',
    },
    isEmpty: {
      label: 'isEmpty',
    },
    keys: {
      label: 'keys',
    },
    labels: {
      label: 'labels',
    },
    last: {
      label: 'last',
    },
    left: {
      label: 'left',
    },
    length: {
      label: 'length',
    },
    linenumber: {
      label: 'linenumber',
    },
    localdatetime: {
      label: 'localdatetime',
    },
    'localdatetime.realtime': {
      label: 'localdatetime.realtime',
    },
    'localdatetime.statement': {
      label: 'localdatetime.statement',
    },
    'localdatetime.transaction': {
      label: 'localdatetime.transaction',
    },
    'localdatetime.truncate': {
      label: 'localdatetime.truncate',
    },
    localtime: {
      label: 'localtime',
    },
    'localtime.realtime': {
      label: 'localtime.realtime',
    },
    'localtime.statement': {
      label: 'localtime.statement',
    },
    'localtime.transaction': {
      label: 'localtime.transaction',
    },
    'localtime.truncate': {
      label: 'localtime.truncate',
    },
    log: {
      label: 'log',
    },
    log10: {
      label: 'log10',
    },
    ltrim: {
      label: 'ltrim',
    },
    max: {
      label: 'max',
    },
    min: {
      label: 'min',
    },
    nodes: {
      label: 'nodes',
    },
    none: {
      label: 'none',
    },
    percentileCont: {
      label: 'percentileCont',
    },
    percentileDisc: {
      label: 'percentileDisc',
    },
    pi: {
      label: 'pi',
    },
    point: {
      label: 'point',
    },
    'point.distance': {
      label: 'point.distance',
    },
    'point.withinBBox': {
      label: 'point.withinBBox',
    },
    properties: {
      label: 'properties',
    },
    radians: {
      label: 'radians',
    },
    rand: {
      label: 'rand',
    },
    randomUUID: {
      label: 'randomUUID',
    },
    range: {
      label: 'range',
    },
    reduce: {
      label: 'reduce',
    },
    relationships: {
      label: 'relationships',
    },
    replace: {
      label: 'replace',
    },
    reverse: {
      label: 'reverse',
    },
    right: {
      label: 'right',
    },
    round: {
      label: 'round',
    },
    rtrim: {
      label: 'rtrim',
    },
    sign: {
      label: 'sign',
    },
    sin: {
      label: 'sin',
    },
    single: {
      label: 'single',
    },
    size: {
      label: 'size',
    },
    split: {
      label: 'split',
    },
    sqrt: {
      label: 'sqrt',
    },
    startNode: {
      label: 'startNode',
    },
    stdev: {
      label: 'stdev',
    },
    stdevp: {
      label: 'stdevp',
    },
    substring: {
      label: 'substring',
    },
    sum: {
      label: 'sum',
    },
    tail: {
      label: 'tail',
    },
    tan: {
      label: 'tan',
    },
    time: {
      label: 'time',
    },
    'time.realtime': {
      label: 'time.realtime',
    },
    'time.statement': {
      label: 'time.statement',
    },
    'time.transaction': {
      label: 'time.transaction',
    },
    'time.truncate': {
      label: 'time.truncate',
    },
    toBoolean: {
      label: 'toBoolean',
    },
    toBooleanList: {
      label: 'toBooleanList',
    },
    toBooleanOrNull: {
      label: 'toBooleanOrNull',
    },
    toFloat: {
      label: 'toFloat',
    },
    toFloatList: {
      label: 'toFloatList',
    },
    toFloatOrNull: {
      label: 'toFloatOrNull',
    },
    toInteger: {
      label: 'toInteger',
    },
    toIntegerList: {
      label: 'toIntegerList',
    },
    toIntegerOrNull: {
      label: 'toIntegerOrNull',
    },
    toLower: {
      label: 'toLower',
    },
    toStringList: {
      label: 'toStringList',
    },
    toStringOrNull: {
      label: 'toStringOrNull',
    },
    toUpper: {
      label: 'toUpper',
    },
    trim: {
      label: 'trim',
    },
    type: {
      label: 'type',
    },
  },
  procedureSignatures: {
    'apoc.algo.aStar': {
      label: 'apoc.algo.aStar',
      documentation:
        'Runs the A* search algorithm to find the optimal path between two nodes, using the given relationship property name for the cost function.',
      parameters: [
        {
          label: 'startNode',
          documentation: 'startNode :: NODE?',
        },
        {
          label: 'endNode',
          documentation: 'endNode :: NODE?',
        },
        {
          label: 'relTypesAndDirections',
          documentation: 'relTypesAndDirections :: STRING?',
        },
        {
          label: 'weightPropertyName',
          documentation: 'weightPropertyName :: STRING?',
        },
        {
          label: 'latPropertyName',
          documentation: 'latPropertyName :: STRING?',
        },
        {
          label: 'lonPropertyName',
          documentation: 'lonPropertyName :: STRING?',
        },
      ],
    },
    'apoc.algo.aStarConfig': {
      label: 'apoc.algo.aStarConfig',
      documentation:
        'Runs the A* search algorithm to find the optimal path between two nodes, using the given relationship property name for the cost function.\nThis procedure looks for weight, latitude and longitude properties in the config.',
      parameters: [
        {
          label: 'startNode',
          documentation: 'startNode :: NODE?',
        },
        {
          label: 'endNode',
          documentation: 'endNode :: NODE?',
        },
        {
          label: 'relTypesAndDirections',
          documentation: 'relTypesAndDirections :: STRING?',
        },
        {
          label: 'config',
          documentation: 'config :: MAP?',
        },
      ],
    },
    'apoc.algo.allSimplePaths': {
      label: 'apoc.algo.allSimplePaths',
      documentation:
        'Runs a search algorithm to find all of the simple paths between the given relationships, up to a max depth described by maxNodes.',
      parameters: [
        {
          label: 'startNode',
          documentation: 'startNode :: NODE?',
        },
        {
          label: 'endNode',
          documentation: 'endNode :: NODE?',
        },
        {
          label: 'relTypesAndDirections',
          documentation: 'relTypesAndDirections :: STRING?',
        },
        {
          label: 'maxNodes',
          documentation: 'maxNodes :: INTEGER?',
        },
      ],
    },
    'apoc.algo.cover': {
      label: 'apoc.algo.cover',
      documentation: 'Returns all relationships between a given set of nodes.',
      parameters: [
        {
          label: 'nodes',
          documentation: 'nodes :: ANY?',
        },
      ],
    },
    'apoc.algo.dijkstra': {
      label: 'apoc.algo.dijkstra',
      documentation:
        "Runs Dijkstra's algorithm using the given relationship property as the cost function.",
      parameters: [
        {
          label: 'startNode',
          documentation: 'startNode :: NODE?',
        },
        {
          label: 'endNode',
          documentation: 'endNode :: NODE?',
        },
        {
          label: 'relTypesAndDirections',
          documentation: 'relTypesAndDirections :: STRING?',
        },
        {
          label: 'weightPropertyName',
          documentation: 'weightPropertyName :: STRING?',
        },
        {
          label: 'defaultWeight',
          documentation: 'defaultWeight = NaN :: FLOAT?',
        },
        {
          label: 'numberOfWantedPaths',
          documentation: 'numberOfWantedPaths = 1 :: INTEGER?',
        },
      ],
    },
    'apoc.atomic.add': {
      label: 'apoc.atomic.add',
      documentation:
        'Sets the given property to the sum of itself and the number value.\nThe procedure then sets the property to the returned sum.',
      parameters: [
        {
          label: 'container',
          documentation: 'container :: ANY?',
        },
        {
          label: 'propertyName',
          documentation: 'propertyName :: STRING?',
        },
        {
          label: 'number',
          documentation: 'number :: NUMBER?',
        },
        {
          label: 'retryAttempts',
          documentation: 'retryAttempts = 5 :: INTEGER?',
        },
      ],
    },
    'apoc.atomic.concat': {
      label: 'apoc.atomic.concat',
      documentation:
        'Sets the given property to the concatenation of itself and the string value.\nThe procedure then sets the property to the returned string.',
      parameters: [
        {
          label: 'container',
          documentation: 'container :: ANY?',
        },
        {
          label: 'propertyName',
          documentation: 'propertyName :: STRING?',
        },
        {
          label: 'string',
          documentation: 'string :: STRING?',
        },
        {
          label: 'retryAttempts',
          documentation: 'retryAttempts = 5 :: INTEGER?',
        },
      ],
    },
    'apoc.atomic.insert': {
      label: 'apoc.atomic.insert',
      documentation:
        'Inserts a value at position into the array value of a property.\nThe procedure then sets the result back on the property.',
      parameters: [
        {
          label: 'container',
          documentation: 'container :: ANY?',
        },
        {
          label: 'propertyName',
          documentation: 'propertyName :: STRING?',
        },
        {
          label: 'position',
          documentation: 'position :: INTEGER?',
        },
        {
          label: 'value',
          documentation: 'value :: ANY?',
        },
        {
          label: 'retryAttempts',
          documentation: 'retryAttempts = 5 :: INTEGER?',
        },
      ],
    },
    'apoc.atomic.remove': {
      label: 'apoc.atomic.remove',
      documentation:
        'Removes the element at position from the array value of a property.\nThe procedure then sets the property to the resulting array value.',
      parameters: [
        {
          label: 'container',
          documentation: 'container :: ANY?',
        },
        {
          label: 'propertyName',
          documentation: 'propertyName :: STRING?',
        },
        {
          label: 'position',
          documentation: 'position :: INTEGER?',
        },
        {
          label: 'retryAttempts',
          documentation: 'retryAttempts = 5 :: INTEGER?',
        },
      ],
    },
    'apoc.atomic.subtract': {
      label: 'apoc.atomic.subtract',
      documentation:
        'Sets the property of a value to itself minus the given number value.\nThe procedure then sets the property to the returned sum.',
      parameters: [
        {
          label: 'container',
          documentation: 'container :: ANY?',
        },
        {
          label: 'propertyName',
          documentation: 'propertyName :: STRING?',
        },
        {
          label: 'number',
          documentation: 'number :: NUMBER?',
        },
        {
          label: 'retryAttempts',
          documentation: 'retryAttempts = 5 :: INTEGER?',
        },
      ],
    },
    'apoc.atomic.update': {
      label: 'apoc.atomic.update',
      documentation: 'Updates the value of a property with a Cypher operation.',
      parameters: [
        {
          label: 'container',
          documentation: 'container :: ANY?',
        },
        {
          label: 'propertyName',
          documentation: 'propertyName :: STRING?',
        },
        {
          label: 'operation',
          documentation: 'operation :: STRING?',
        },
        {
          label: 'retryAttempts',
          documentation: 'retryAttempts = 5 :: INTEGER?',
        },
      ],
    },
    'apoc.case': {
      label: 'apoc.case',
      documentation:
        'For each pair of conditional and read-only queries in the given list, this procedure will run the first query for which the conditional is evaluated to true.',
      parameters: [
        {
          label: 'conditionals',
          documentation: 'conditionals :: LIST? OF ANY?',
        },
        {
          label: 'elseQuery',
          documentation: 'elseQuery =  :: STRING?',
        },
        {
          label: 'params',
          documentation: 'params = {} :: MAP?',
        },
      ],
    },
    'apoc.coll.elements': {
      label: 'apoc.coll.elements',
      documentation:
        'Deconstructs a list of mixed types into identifiers indicating their specific type.',
      parameters: [
        {
          label: 'coll',
          documentation: 'coll :: LIST? OF ANY?',
        },
        {
          label: 'limit',
          documentation: 'limit = -1 :: INTEGER?',
        },
        {
          label: 'offset',
          documentation: 'offset = 0 :: INTEGER?',
        },
      ],
    },
    'apoc.coll.pairWithOffset': {
      label: 'apoc.coll.pairWithOffset',
      documentation: 'Returns a list of pairs defined by the offset.',
      parameters: [
        {
          label: 'coll',
          documentation: 'coll :: LIST? OF ANY?',
        },
        {
          label: 'offset',
          documentation: 'offset :: INTEGER?',
        },
      ],
    },
    'apoc.coll.partition': {
      label: 'apoc.coll.partition',
      documentation:
        'Partitions the original list into sub-lists of the given batch size.\nThe final list may be smaller than the given batch size.',
      parameters: [
        {
          label: 'coll',
          documentation: 'coll :: LIST? OF ANY?',
        },
        {
          label: 'batchSize',
          documentation: 'batchSize :: INTEGER?',
        },
      ],
    },
    'apoc.coll.split': {
      label: 'apoc.coll.split',
      documentation:
        'Splits a collection by the given value. The value itself will not be part of the resulting lists.',
      parameters: [
        {
          label: 'coll',
          documentation: 'coll :: LIST? OF ANY?',
        },
        {
          label: 'value',
          documentation: 'value :: ANY?',
        },
      ],
    },
    'apoc.coll.zipToRows': {
      label: 'apoc.coll.zipToRows',
      documentation:
        'Returns the two lists zipped together, with one row per zipped pair.',
      parameters: [
        {
          label: 'list1',
          documentation: 'list1 :: LIST? OF ANY?',
        },
        {
          label: 'list2',
          documentation: 'list2 :: LIST? OF ANY?',
        },
      ],
    },
    'apoc.convert.setJsonProperty': {
      label: 'apoc.convert.setJsonProperty',
      documentation:
        'Serializes the given JSON object and sets it as a property on the given node.',
      parameters: [
        {
          label: 'node',
          documentation: 'node :: NODE?',
        },
        {
          label: 'key',
          documentation: 'key :: STRING?',
        },
        {
          label: 'value',
          documentation: 'value :: ANY?',
        },
      ],
    },
    'apoc.convert.toTree': {
      label: 'apoc.convert.toTree',
      documentation:
        'Returns a stream of maps, representing the given paths as a tree with at least one root.',
      parameters: [
        {
          label: 'paths',
          documentation: 'paths :: LIST? OF PATH?',
        },
        {
          label: 'lowerCaseRels',
          documentation: 'lowerCaseRels = true :: BOOLEAN?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.create.addLabels': {
      label: 'apoc.create.addLabels',
      documentation: 'Adds the given labels to the given nodes.',
      parameters: [
        {
          label: 'nodes',
          documentation: 'nodes :: ANY?',
        },
        {
          label: 'labels',
          documentation: 'labels :: LIST? OF STRING?',
        },
      ],
    },
    'apoc.create.clonePathToVirtual': {
      label: 'apoc.create.clonePathToVirtual',
      documentation:
        'Takes the given path and returns a virtual representation of it.',
      parameters: [
        {
          label: 'path',
          documentation: 'path :: PATH?',
        },
      ],
    },
    'apoc.create.clonePathsToVirtual': {
      label: 'apoc.create.clonePathsToVirtual',
      documentation:
        'Takes the given paths and returns a virtual representation of them.',
      parameters: [
        {
          label: 'paths',
          documentation: 'paths :: LIST? OF PATH?',
        },
      ],
    },
    'apoc.create.node': {
      label: 'apoc.create.node',
      documentation: 'Creates a node with the given dynamic labels.',
      parameters: [
        {
          label: 'labels',
          documentation: 'labels :: LIST? OF STRING?',
        },
        {
          label: 'props',
          documentation: 'props :: MAP?',
        },
      ],
    },
    'apoc.create.nodes': {
      label: 'apoc.create.nodes',
      documentation: 'Creates nodes with the given dynamic labels.',
      parameters: [
        {
          label: 'labels',
          documentation: 'labels :: LIST? OF STRING?',
        },
        {
          label: 'props',
          documentation: 'props :: LIST? OF MAP?',
        },
      ],
    },
    'apoc.create.relationship': {
      label: 'apoc.create.relationship',
      documentation:
        'Creates a relationship with the given dynamic relationship type.',
      parameters: [
        {
          label: 'from',
          documentation: 'from :: NODE?',
        },
        {
          label: 'relType',
          documentation: 'relType :: STRING?',
        },
        {
          label: 'props',
          documentation: 'props :: MAP?',
        },
        {
          label: 'to',
          documentation: 'to :: NODE?',
        },
      ],
    },
    'apoc.create.removeLabels': {
      label: 'apoc.create.removeLabels',
      documentation: 'Removes the given labels from the given node(s).',
      parameters: [
        {
          label: 'nodes',
          documentation: 'nodes :: ANY?',
        },
        {
          label: 'labels',
          documentation: 'labels :: LIST? OF STRING?',
        },
      ],
    },
    'apoc.create.removeProperties': {
      label: 'apoc.create.removeProperties',
      documentation: 'Removes the given properties from the given node(s).',
      parameters: [
        {
          label: 'nodes',
          documentation: 'nodes :: ANY?',
        },
        {
          label: 'keys',
          documentation: 'keys :: LIST? OF STRING?',
        },
      ],
    },
    'apoc.create.removeRelProperties': {
      label: 'apoc.create.removeRelProperties',
      documentation:
        'Removes the given properties from the given relationship(s).',
      parameters: [
        {
          label: 'rels',
          documentation: 'rels :: ANY?',
        },
        {
          label: 'keys',
          documentation: 'keys :: LIST? OF STRING?',
        },
      ],
    },
    'apoc.create.setLabels': {
      label: 'apoc.create.setLabels',
      documentation:
        'Sets the given labels to the given node(s). Non-matching labels are removed from the nodes.',
      parameters: [
        {
          label: 'nodes',
          documentation: 'nodes :: ANY?',
        },
        {
          label: 'labels',
          documentation: 'labels :: LIST? OF STRING?',
        },
      ],
    },
    'apoc.create.setProperties': {
      label: 'apoc.create.setProperties',
      documentation: 'Sets the given properties to the given node(s).',
      parameters: [
        {
          label: 'nodes',
          documentation: 'nodes :: ANY?',
        },
        {
          label: 'keys',
          documentation: 'keys :: LIST? OF STRING?',
        },
        {
          label: 'values',
          documentation: 'values :: LIST? OF ANY?',
        },
      ],
    },
    'apoc.create.setProperty': {
      label: 'apoc.create.setProperty',
      documentation: 'Sets the given property to the given node(s).',
      parameters: [
        {
          label: 'nodes',
          documentation: 'nodes :: ANY?',
        },
        {
          label: 'key',
          documentation: 'key :: STRING?',
        },
        {
          label: 'value',
          documentation: 'value :: ANY?',
        },
      ],
    },
    'apoc.create.setRelProperties': {
      label: 'apoc.create.setRelProperties',
      documentation: 'Sets the given properties on the relationship(s).',
      parameters: [
        {
          label: 'rels',
          documentation: 'rels :: ANY?',
        },
        {
          label: 'keys',
          documentation: 'keys :: LIST? OF STRING?',
        },
        {
          label: 'values',
          documentation: 'values :: LIST? OF ANY?',
        },
      ],
    },
    'apoc.create.setRelProperty': {
      label: 'apoc.create.setRelProperty',
      documentation: 'Sets the given property on the relationship(s).',
      parameters: [
        {
          label: 'rels',
          documentation: 'rels :: ANY?',
        },
        {
          label: 'key',
          documentation: 'key :: STRING?',
        },
        {
          label: 'value',
          documentation: 'value :: ANY?',
        },
      ],
    },
    'apoc.create.uuids': {
      label: 'apoc.create.uuids',
      documentation: 'Returns a stream of UUIDs.',
      parameters: [
        {
          label: 'count',
          documentation: 'count :: INTEGER?',
        },
      ],
    },
    'apoc.create.vNode': {
      label: 'apoc.create.vNode',
      documentation: 'Returns a virtual node.',
      parameters: [
        {
          label: 'labels',
          documentation: 'labels :: LIST? OF STRING?',
        },
        {
          label: 'props',
          documentation: 'props :: MAP?',
        },
      ],
    },
    'apoc.create.vNodes': {
      label: 'apoc.create.vNodes',
      documentation: 'Returns virtual nodes.',
      parameters: [
        {
          label: 'labels',
          documentation: 'labels :: LIST? OF STRING?',
        },
        {
          label: 'props',
          documentation: 'props :: LIST? OF MAP?',
        },
      ],
    },
    'apoc.create.vRelationship': {
      label: 'apoc.create.vRelationship',
      documentation: 'Returns a virtual relationship.',
      parameters: [
        {
          label: 'from',
          documentation: 'from :: NODE?',
        },
        {
          label: 'relType',
          documentation: 'relType :: STRING?',
        },
        {
          label: 'props',
          documentation: 'props :: MAP?',
        },
        {
          label: 'to',
          documentation: 'to :: NODE?',
        },
      ],
    },
    'apoc.create.virtualPath': {
      label: 'apoc.create.virtualPath',
      documentation: 'Returns a virtual path.',
      parameters: [
        {
          label: 'labelsN',
          documentation: 'labelsN :: LIST? OF STRING?',
        },
        {
          label: 'n',
          documentation: 'n :: MAP?',
        },
        {
          label: 'relType',
          documentation: 'relType :: STRING?',
        },
        {
          label: 'props',
          documentation: 'props :: MAP?',
        },
        {
          label: 'labelsM',
          documentation: 'labelsM :: LIST? OF STRING?',
        },
        {
          label: 'm',
          documentation: 'm :: MAP?',
        },
      ],
    },
    'apoc.cypher.doIt': {
      label: 'apoc.cypher.doIt',
      documentation:
        'Runs a dynamically constructed string with the given parameters.',
      parameters: [
        {
          label: 'statement',
          documentation: 'statement :: STRING?',
        },
        {
          label: 'params',
          documentation: 'params :: MAP?',
        },
      ],
    },
    'apoc.cypher.run': {
      label: 'apoc.cypher.run',
      documentation:
        'Runs a dynamically constructed read-only string with the given parameters.',
      parameters: [
        {
          label: 'statement',
          documentation: 'statement :: STRING?',
        },
        {
          label: 'params',
          documentation: 'params :: MAP?',
        },
      ],
    },
    'apoc.cypher.runMany': {
      label: 'apoc.cypher.runMany',
      documentation:
        'Runs each semicolon separated statement and returns a summary of the statement outcomes.',
      parameters: [
        {
          label: 'statement',
          documentation: 'statement :: STRING?',
        },
        {
          label: 'params',
          documentation: 'params :: MAP?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.cypher.runManyReadOnly': {
      label: 'apoc.cypher.runManyReadOnly',
      documentation:
        'Runs each semicolon separated read-only statement and returns a summary of the statement outcomes.',
      parameters: [
        {
          label: 'statement',
          documentation: 'statement :: STRING?',
        },
        {
          label: 'params',
          documentation: 'params :: MAP?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.cypher.runSchema': {
      label: 'apoc.cypher.runSchema',
      documentation:
        'Runs the given query schema statement with the given parameters.',
      parameters: [
        {
          label: 'statement',
          documentation: 'statement :: STRING?',
        },
        {
          label: 'params',
          documentation: 'params :: MAP?',
        },
      ],
    },
    'apoc.cypher.runTimeboxed': {
      label: 'apoc.cypher.runTimeboxed',
      documentation:
        'Terminates a Cypher statement if it has not finished before the set timeout (ms).',
      parameters: [
        {
          label: 'statement',
          documentation: 'statement :: STRING?',
        },
        {
          label: 'params',
          documentation: 'params :: MAP?',
        },
        {
          label: 'timeout',
          documentation: 'timeout :: INTEGER?',
        },
      ],
    },
    'apoc.cypher.runWrite': {
      label: 'apoc.cypher.runWrite',
      documentation: 'Alias for `apoc.cypher.doIt`.',
      parameters: [
        {
          label: 'statement',
          documentation: 'statement :: STRING?',
        },
        {
          label: 'params',
          documentation: 'params :: MAP?',
        },
      ],
    },
    'apoc.do.case': {
      label: 'apoc.do.case',
      documentation:
        'For each pair of conditional queries in the given list, this procedure will run the first query for which the conditional is evaluated to true.',
      parameters: [
        {
          label: 'conditionals',
          documentation: 'conditionals :: LIST? OF ANY?',
        },
        {
          label: 'elseQuery',
          documentation: 'elseQuery =  :: STRING?',
        },
        {
          label: 'params',
          documentation: 'params = {} :: MAP?',
        },
      ],
    },
    'apoc.do.when': {
      label: 'apoc.do.when',
      documentation:
        'Runs the given read/write ifQuery if the conditional has evaluated to true, otherwise the elseQuery will run.',
      parameters: [
        {
          label: 'condition',
          documentation: 'condition :: BOOLEAN?',
        },
        {
          label: 'ifQuery',
          documentation: 'ifQuery :: STRING?',
        },
        {
          label: 'elseQuery',
          documentation: 'elseQuery =  :: STRING?',
        },
        {
          label: 'params',
          documentation: 'params = {} :: MAP?',
        },
      ],
    },
    'apoc.example.movies': {
      label: 'apoc.example.movies',
      documentation: 'Seeds the database with the Neo4j movie dataset.',
      parameters: [],
    },
    'apoc.export.arrow.all': {
      label: 'apoc.export.arrow.all',
      documentation: 'Exports the full database as an arrow file.',
      parameters: [
        {
          label: 'file',
          documentation: 'file :: STRING?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.export.arrow.graph': {
      label: 'apoc.export.arrow.graph',
      documentation: 'Exports the given graph as an arrow file.',
      parameters: [
        {
          label: 'file',
          documentation: 'file :: STRING?',
        },
        {
          label: 'graph',
          documentation: 'graph :: ANY?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.export.arrow.query': {
      label: 'apoc.export.arrow.query',
      documentation:
        'Exports the results from the given Cypher query as an arrow file.',
      parameters: [
        {
          label: 'file',
          documentation: 'file :: STRING?',
        },
        {
          label: 'query',
          documentation: 'query :: STRING?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.export.arrow.stream.all': {
      label: 'apoc.export.arrow.stream.all',
      documentation: 'Exports the full database as an arrow byte array.',
      parameters: [
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.export.arrow.stream.graph': {
      label: 'apoc.export.arrow.stream.graph',
      documentation: 'Exports the given graph as an arrow byte array.',
      parameters: [
        {
          label: 'graph',
          documentation: 'graph :: ANY?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.export.arrow.stream.query': {
      label: 'apoc.export.arrow.stream.query',
      documentation: 'Exports the given Cypher query as an arrow byte array.',
      parameters: [
        {
          label: 'query',
          documentation: 'query :: STRING?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.export.csv.all': {
      label: 'apoc.export.csv.all',
      documentation: 'Exports the full database to the provided CSV file.',
      parameters: [
        {
          label: 'file',
          documentation: 'file :: STRING?',
        },
        {
          label: 'config',
          documentation: 'config :: MAP?',
        },
      ],
    },
    'apoc.export.csv.data': {
      label: 'apoc.export.csv.data',
      documentation:
        'Exports the given nodes and relationships to the provided CSV file.',
      parameters: [
        {
          label: 'nodes',
          documentation: 'nodes :: LIST? OF NODE?',
        },
        {
          label: 'rels',
          documentation: 'rels :: LIST? OF RELATIONSHIP?',
        },
        {
          label: 'file',
          documentation: 'file :: STRING?',
        },
        {
          label: 'config',
          documentation: 'config :: MAP?',
        },
      ],
    },
    'apoc.export.csv.graph': {
      label: 'apoc.export.csv.graph',
      documentation: 'Exports the given graph to the provided CSV file.',
      parameters: [
        {
          label: 'graph',
          documentation: 'graph :: MAP?',
        },
        {
          label: 'file',
          documentation: 'file :: STRING?',
        },
        {
          label: 'config',
          documentation: 'config :: MAP?',
        },
      ],
    },
    'apoc.export.csv.query': {
      label: 'apoc.export.csv.query',
      documentation:
        'Exports the results from running the given Cypher query to the provided CSV file.',
      parameters: [
        {
          label: 'query',
          documentation: 'query :: STRING?',
        },
        {
          label: 'file',
          documentation: 'file :: STRING?',
        },
        {
          label: 'config',
          documentation: 'config :: MAP?',
        },
      ],
    },
    'apoc.export.cypher.all': {
      label: 'apoc.export.cypher.all',
      documentation:
        'Exports the full database (incl. indexes) as Cypher statements to the provided file (default: Cypher Shell).',
      parameters: [
        {
          label: 'file',
          documentation: 'file =  :: STRING?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.export.cypher.data': {
      label: 'apoc.export.cypher.data',
      documentation:
        'Exports the given nodes and relationships (incl. indexes) as Cypher statements to the provided file (default: Cypher Shell).',
      parameters: [
        {
          label: 'nodes',
          documentation: 'nodes :: LIST? OF NODE?',
        },
        {
          label: 'rels',
          documentation: 'rels :: LIST? OF RELATIONSHIP?',
        },
        {
          label: 'file',
          documentation: 'file =  :: STRING?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.export.cypher.graph': {
      label: 'apoc.export.cypher.graph',
      documentation:
        'Exports the given graph (incl. indexes) as Cypher statements to the provided file (default: Cypher Shell).',
      parameters: [
        {
          label: 'graph',
          documentation: 'graph :: MAP?',
        },
        {
          label: 'file',
          documentation: 'file =  :: STRING?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.export.cypher.query': {
      label: 'apoc.export.cypher.query',
      documentation:
        'Exports the nodes and relationships from the given Cypher query (incl. indexes) as Cypher statements to the provided file (default: Cypher Shell).',
      parameters: [
        {
          label: 'statement',
          documentation: 'statement :: STRING?',
        },
        {
          label: 'file',
          documentation: 'file =  :: STRING?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.export.cypher.schema': {
      label: 'apoc.export.cypher.schema',
      documentation:
        'Exports all schema indexes and constraints to Cypher statements.',
      parameters: [
        {
          label: 'file',
          documentation: 'file =  :: STRING?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.export.graphml.all': {
      label: 'apoc.export.graphml.all',
      documentation: 'Exports the full database to the provided GraphML file.',
      parameters: [
        {
          label: 'file',
          documentation: 'file :: STRING?',
        },
        {
          label: 'config',
          documentation: 'config :: MAP?',
        },
      ],
    },
    'apoc.export.graphml.data': {
      label: 'apoc.export.graphml.data',
      documentation:
        'Exports the given nodes and relationships to the provided GraphML file.',
      parameters: [
        {
          label: 'nodes',
          documentation: 'nodes :: LIST? OF NODE?',
        },
        {
          label: 'rels',
          documentation: 'rels :: LIST? OF RELATIONSHIP?',
        },
        {
          label: 'file',
          documentation: 'file :: STRING?',
        },
        {
          label: 'config',
          documentation: 'config :: MAP?',
        },
      ],
    },
    'apoc.export.graphml.graph': {
      label: 'apoc.export.graphml.graph',
      documentation: 'Exports the given graph to the provided GraphML file.',
      parameters: [
        {
          label: 'graph',
          documentation: 'graph :: MAP?',
        },
        {
          label: 'file',
          documentation: 'file :: STRING?',
        },
        {
          label: 'config',
          documentation: 'config :: MAP?',
        },
      ],
    },
    'apoc.export.graphml.query': {
      label: 'apoc.export.graphml.query',
      documentation:
        'Exports the given nodes and relationships from the Cypher statement to the provided GraphML file.',
      parameters: [
        {
          label: 'statement',
          documentation: 'statement :: STRING?',
        },
        {
          label: 'file',
          documentation: 'file :: STRING?',
        },
        {
          label: 'config',
          documentation: 'config :: MAP?',
        },
      ],
    },
    'apoc.export.json.all': {
      label: 'apoc.export.json.all',
      documentation: 'Exports the full database to the provided JSON file.',
      parameters: [
        {
          label: 'file',
          documentation: 'file :: STRING?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.export.json.data': {
      label: 'apoc.export.json.data',
      documentation:
        'Exports the given nodes and relationships to the provided JSON file.',
      parameters: [
        {
          label: 'nodes',
          documentation: 'nodes :: LIST? OF NODE?',
        },
        {
          label: 'rels',
          documentation: 'rels :: LIST? OF RELATIONSHIP?',
        },
        {
          label: 'file',
          documentation: 'file :: STRING?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.export.json.graph': {
      label: 'apoc.export.json.graph',
      documentation: 'Exports the given graph to the provided JSON file.',
      parameters: [
        {
          label: 'graph',
          documentation: 'graph :: MAP?',
        },
        {
          label: 'file',
          documentation: 'file :: STRING?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.export.json.query': {
      label: 'apoc.export.json.query',
      documentation:
        'Exports the results from the Cypher statement to the provided JSON file.',
      parameters: [
        {
          label: 'statement',
          documentation: 'statement :: STRING?',
        },
        {
          label: 'file',
          documentation: 'file :: STRING?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.graph.from': {
      label: 'apoc.graph.from',
      documentation:
        'Generates a virtual sub-graph by extracting all of the nodes and relationships from the given data.',
      parameters: [
        {
          label: 'data',
          documentation: 'data :: ANY?',
        },
        {
          label: 'name',
          documentation: 'name :: STRING?',
        },
        {
          label: 'props',
          documentation: 'props :: MAP?',
        },
      ],
    },
    'apoc.graph.fromCypher': {
      label: 'apoc.graph.fromCypher',
      documentation:
        'Generates a virtual sub-graph by extracting all of the nodes and relationships from the data returned by the given Cypher statement.',
      parameters: [
        {
          label: 'statement',
          documentation: 'statement :: STRING?',
        },
        {
          label: 'params',
          documentation: 'params :: MAP?',
        },
        {
          label: 'name',
          documentation: 'name :: STRING?',
        },
        {
          label: 'props',
          documentation: 'props :: MAP?',
        },
      ],
    },
    'apoc.graph.fromDB': {
      label: 'apoc.graph.fromDB',
      documentation:
        'Generates a virtual sub-graph by extracting all of the nodes and relationships from the data returned by the given database.',
      parameters: [
        {
          label: 'name',
          documentation: 'name :: STRING?',
        },
        {
          label: 'props',
          documentation: 'props :: MAP?',
        },
      ],
    },
    'apoc.graph.fromData': {
      label: 'apoc.graph.fromData',
      documentation:
        'Generates a virtual sub-graph by extracting all of the nodes and relationships from the given data.',
      parameters: [
        {
          label: 'nodes',
          documentation: 'nodes :: LIST? OF NODE?',
        },
        {
          label: 'rels',
          documentation: 'rels :: LIST? OF RELATIONSHIP?',
        },
        {
          label: 'name',
          documentation: 'name :: STRING?',
        },
        {
          label: 'props',
          documentation: 'props :: MAP?',
        },
      ],
    },
    'apoc.graph.fromDocument': {
      label: 'apoc.graph.fromDocument',
      documentation:
        'Generates a virtual sub-graph by extracting all of the nodes and relationships from the data returned by the given JSON file.',
      parameters: [
        {
          label: 'json',
          documentation: 'json :: ANY?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.graph.fromPath': {
      label: 'apoc.graph.fromPath',
      documentation:
        'Generates a virtual sub-graph by extracting all of the nodes and relationships from the data returned by the given path.',
      parameters: [
        {
          label: 'path',
          documentation: 'path :: PATH?',
        },
        {
          label: 'name',
          documentation: 'name :: STRING?',
        },
        {
          label: 'props',
          documentation: 'props :: MAP?',
        },
      ],
    },
    'apoc.graph.fromPaths': {
      label: 'apoc.graph.fromPaths',
      documentation:
        'Generates a virtual sub-graph by extracting all of the nodes and relationships from the data returned by the given paths.',
      parameters: [
        {
          label: 'paths',
          documentation: 'paths :: LIST? OF PATH?',
        },
        {
          label: 'name',
          documentation: 'name :: STRING?',
        },
        {
          label: 'props',
          documentation: 'props :: MAP?',
        },
      ],
    },
    'apoc.graph.validateDocument': {
      label: 'apoc.graph.validateDocument',
      documentation:
        'Validates the JSON file and returns the result of the validation.',
      parameters: [
        {
          label: 'json',
          documentation: 'json :: ANY?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.help': {
      label: 'apoc.help',
      documentation:
        'Returns descriptions of the available APOC procedures and functions.',
      parameters: [
        {
          label: 'proc',
          documentation: 'proc :: STRING?',
        },
      ],
    },
    'apoc.import.csv': {
      label: 'apoc.import.csv',
      documentation:
        'Imports nodes and relationships with the given labels and types from the provided CSV file.',
      parameters: [
        {
          label: 'nodes',
          documentation: 'nodes :: LIST? OF MAP?',
        },
        {
          label: 'rels',
          documentation: 'rels :: LIST? OF MAP?',
        },
        {
          label: 'config',
          documentation: 'config :: MAP?',
        },
      ],
    },
    'apoc.import.graphml': {
      label: 'apoc.import.graphml',
      documentation: 'Imports a graph from the provided GraphML file.',
      parameters: [
        {
          label: 'urlOrBinaryFile',
          documentation: 'urlOrBinaryFile :: ANY?',
        },
        {
          label: 'config',
          documentation: 'config :: MAP?',
        },
      ],
    },
    'apoc.import.json': {
      label: 'apoc.import.json',
      documentation: 'Imports a graph from the provided JSON file.',
      parameters: [
        {
          label: 'urlOrBinaryFile',
          documentation: 'urlOrBinaryFile :: ANY?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.import.xml': {
      label: 'apoc.import.xml',
      documentation: 'Imports a graph from the provided XML file.',
      parameters: [
        {
          label: 'urlOrBinary',
          documentation: 'urlOrBinary :: ANY?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.load.arrow': {
      label: 'apoc.load.arrow',
      documentation:
        'Imports nodes and relationships from the provided arrow file.',
      parameters: [
        {
          label: 'file',
          documentation: 'file :: STRING?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.load.arrow.stream': {
      label: 'apoc.load.arrow.stream',
      documentation:
        'Imports nodes and relationships from the provided arrow byte array.',
      parameters: [
        {
          label: 'source',
          documentation: 'source :: BYTEARRAY?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.load.json': {
      label: 'apoc.load.json',
      documentation:
        'Imports JSON file as a stream of values if the given JSON file is an array.\nIf the given JSON file is a map, this procedure imports a single value instead.',
      parameters: [
        {
          label: 'urlOrKeyOrBinary',
          documentation: 'urlOrKeyOrBinary :: ANY?',
        },
        {
          label: 'path',
          documentation: 'path =  :: STRING?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.load.jsonArray': {
      label: 'apoc.load.jsonArray',
      documentation:
        'Loads array from a JSON URL (e.g. web-API) to then import the given JSON file as a stream of values.',
      parameters: [
        {
          label: 'url',
          documentation: 'url :: STRING?',
        },
        {
          label: 'path',
          documentation: 'path =  :: STRING?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.load.jsonParams': {
      label: 'apoc.load.jsonParams',
      documentation:
        'Loads parameters from a JSON URL (e.g. web-API) as a stream of values if the given JSON file is an array.\nIf the given JSON file is a map, this procedure imports a single value instead.',
      parameters: [
        {
          label: 'urlOrKeyOrBinary',
          documentation: 'urlOrKeyOrBinary :: ANY?',
        },
        {
          label: 'headers',
          documentation: 'headers :: MAP?',
        },
        {
          label: 'payload',
          documentation: 'payload :: STRING?',
        },
        {
          label: 'path',
          documentation: 'path =  :: STRING?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.load.xml': {
      label: 'apoc.load.xml',
      documentation:
        'Loads a single nested map from an XML URL (e.g. web-API).',
      parameters: [
        {
          label: 'urlOrBinary',
          documentation: 'urlOrBinary :: ANY?',
        },
        {
          label: 'path',
          documentation: 'path = / :: STRING?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
        {
          label: 'simple',
          documentation: 'simple = false :: BOOLEAN?',
        },
      ],
    },
    'apoc.lock.all': {
      label: 'apoc.lock.all',
      documentation:
        'Acquires a write lock on the given nodes and relationships.',
      parameters: [
        {
          label: 'nodes',
          documentation: 'nodes :: LIST? OF NODE?',
        },
        {
          label: 'rels',
          documentation: 'rels :: LIST? OF RELATIONSHIP?',
        },
      ],
    },
    'apoc.lock.nodes': {
      label: 'apoc.lock.nodes',
      documentation: 'Acquires a write lock on the given nodes.',
      parameters: [
        {
          label: 'nodes',
          documentation: 'nodes :: LIST? OF NODE?',
        },
      ],
    },
    'apoc.lock.read.nodes': {
      label: 'apoc.lock.read.nodes',
      documentation: 'Acquires a read lock on the given nodes.',
      parameters: [
        {
          label: 'nodes',
          documentation: 'nodes :: LIST? OF NODE?',
        },
      ],
    },
    'apoc.lock.read.rels': {
      label: 'apoc.lock.read.rels',
      documentation: 'Acquires a read lock on the given relationships.',
      parameters: [
        {
          label: 'rels',
          documentation: 'rels :: LIST? OF RELATIONSHIP?',
        },
      ],
    },
    'apoc.lock.rels': {
      label: 'apoc.lock.rels',
      documentation: 'Acquires a write lock on the given relationships.',
      parameters: [
        {
          label: 'rels',
          documentation: 'rels :: LIST? OF RELATIONSHIP?',
        },
      ],
    },
    'apoc.log.stream': {
      label: 'apoc.log.stream',
      documentation:
        'Returns the file contents from the given log, optionally returning only the last n lines.\nThis procedure requires users to have an admin role.',
      parameters: [
        {
          label: 'path',
          documentation: 'path :: STRING?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.math.regr': {
      label: 'apoc.math.regr',
      documentation:
        'Returns the coefficient of determination (R-squared) for the values of propertyY and propertyX in the given label.',
      parameters: [
        {
          label: 'label',
          documentation: 'label :: STRING?',
        },
        {
          label: 'propertyY',
          documentation: 'propertyY :: STRING?',
        },
        {
          label: 'propertyX',
          documentation: 'propertyX :: STRING?',
        },
      ],
    },
    'apoc.merge.node': {
      label: 'apoc.merge.node',
      documentation: 'Merges the given node(s) with the given dynamic labels.',
      parameters: [
        {
          label: 'labels',
          documentation: 'labels :: LIST? OF STRING?',
        },
        {
          label: 'identProps',
          documentation: 'identProps :: MAP?',
        },
        {
          label: 'props',
          documentation: 'props = {} :: MAP?',
        },
        {
          label: 'onMatchProps',
          documentation: 'onMatchProps = {} :: MAP?',
        },
      ],
    },
    'apoc.merge.node.eager': {
      label: 'apoc.merge.node.eager',
      documentation:
        'Merges the given node(s) with the given dynamic labels eagerly.',
      parameters: [
        {
          label: 'labels',
          documentation: 'labels :: LIST? OF STRING?',
        },
        {
          label: 'identProps',
          documentation: 'identProps :: MAP?',
        },
        {
          label: 'props',
          documentation: 'props = {} :: MAP?',
        },
        {
          label: 'onMatchProps',
          documentation: 'onMatchProps = {} :: MAP?',
        },
      ],
    },
    'apoc.merge.nodeWithStats': {
      label: 'apoc.merge.nodeWithStats',
      documentation:
        'Merges the given node(s) with the given dynamic labels. Provides queryStatistics in the result.',
      parameters: [
        {
          label: 'labels',
          documentation: 'labels :: LIST? OF STRING?',
        },
        {
          label: 'identProps',
          documentation: 'identProps :: MAP?',
        },
        {
          label: 'props',
          documentation: 'props = {} :: MAP?',
        },
        {
          label: 'onMatchProps',
          documentation: 'onMatchProps = {} :: MAP?',
        },
      ],
    },
    'apoc.merge.nodeWithStats.eager': {
      label: 'apoc.merge.nodeWithStats.eager',
      documentation:
        'Merges the given node(s) with the given dynamic labels eagerly. Provides queryStatistics in the result.',
      parameters: [
        {
          label: 'labels',
          documentation: 'labels :: LIST? OF STRING?',
        },
        {
          label: 'identProps',
          documentation: 'identProps :: MAP?',
        },
        {
          label: 'props',
          documentation: 'props = {} :: MAP?',
        },
        {
          label: 'onMatchProps',
          documentation: 'onMatchProps = {} :: MAP?',
        },
      ],
    },
    'apoc.merge.relationship': {
      label: 'apoc.merge.relationship',
      documentation:
        'Merges the given relationship(s) with the given dynamic types/properties.',
      parameters: [
        {
          label: 'startNode',
          documentation: 'startNode :: NODE?',
        },
        {
          label: 'relType',
          documentation: 'relType :: STRING?',
        },
        {
          label: 'identProps',
          documentation: 'identProps :: MAP?',
        },
        {
          label: 'props',
          documentation: 'props :: MAP?',
        },
        {
          label: 'endNode',
          documentation: 'endNode :: NODE?',
        },
        {
          label: 'onMatchProps',
          documentation: 'onMatchProps = {} :: MAP?',
        },
      ],
    },
    'apoc.merge.relationship.eager': {
      label: 'apoc.merge.relationship.eager',
      documentation:
        'Merges the given relationship(s) with the given dynamic types/properties eagerly.',
      parameters: [
        {
          label: 'startNode',
          documentation: 'startNode :: NODE?',
        },
        {
          label: 'relType',
          documentation: 'relType :: STRING?',
        },
        {
          label: 'identProps',
          documentation: 'identProps :: MAP?',
        },
        {
          label: 'props',
          documentation: 'props :: MAP?',
        },
        {
          label: 'endNode',
          documentation: 'endNode :: NODE?',
        },
        {
          label: 'onMatchProps',
          documentation: 'onMatchProps = {} :: MAP?',
        },
      ],
    },
    'apoc.merge.relationshipWithStats': {
      label: 'apoc.merge.relationshipWithStats',
      documentation:
        'Merges the given relationship(s) with the given dynamic types/properties. Provides queryStatistics in the result.',
      parameters: [
        {
          label: 'startNode',
          documentation: 'startNode :: NODE?',
        },
        {
          label: 'relType',
          documentation: 'relType :: STRING?',
        },
        {
          label: 'identProps',
          documentation: 'identProps :: MAP?',
        },
        {
          label: 'props',
          documentation: 'props :: MAP?',
        },
        {
          label: 'endNode',
          documentation: 'endNode :: NODE?',
        },
        {
          label: 'onMatchProps',
          documentation: 'onMatchProps = {} :: MAP?',
        },
      ],
    },
    'apoc.merge.relationshipWithStats.eager': {
      label: 'apoc.merge.relationshipWithStats.eager',
      documentation:
        'Merges the given relationship(s) with the given dynamic types/properties eagerly. Provides queryStatistics in the result.',
      parameters: [
        {
          label: 'startNode',
          documentation: 'startNode :: NODE?',
        },
        {
          label: 'relType',
          documentation: 'relType :: STRING?',
        },
        {
          label: 'identProps',
          documentation: 'identProps :: MAP?',
        },
        {
          label: 'props',
          documentation: 'props :: MAP?',
        },
        {
          label: 'endNode',
          documentation: 'endNode :: NODE?',
        },
        {
          label: 'onMatchProps',
          documentation: 'onMatchProps = {} :: MAP?',
        },
      ],
    },
    'apoc.meta.data': {
      label: 'apoc.meta.data',
      documentation: 'Examines the full graph and returns a table of metadata.',
      parameters: [
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.meta.data.of': {
      label: 'apoc.meta.data.of',
      documentation:
        'Examines the given sub-graph and returns a table of metadata.',
      parameters: [
        {
          label: 'graph',
          documentation: 'graph :: ANY?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.meta.graph': {
      label: 'apoc.meta.graph',
      documentation: 'Examines the full graph and returns a meta-graph.',
      parameters: [
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.meta.graph.of': {
      label: 'apoc.meta.graph.of',
      documentation: 'Examines the given sub-graph and returns a meta-graph.',
      parameters: [
        {
          label: 'graph',
          documentation: 'graph = {} :: ANY?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.meta.graphSample': {
      label: 'apoc.meta.graphSample',
      documentation:
        'Examines the full graph and returns a meta-graph.\nUnlike `apoc.meta.graph`, this procedure does not filter away non-existing paths.',
      parameters: [
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.meta.nodeTypeProperties': {
      label: 'apoc.meta.nodeTypeProperties',
      documentation:
        'Examines the full graph and returns a table of metadata with information about the nodes therein.',
      parameters: [
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.meta.relTypeProperties': {
      label: 'apoc.meta.relTypeProperties',
      documentation:
        'Examines the full graph and returns a table of metadata with information about the relationships therein.',
      parameters: [
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.meta.schema': {
      label: 'apoc.meta.schema',
      documentation:
        'Examines the given sub-graph and returns metadata as a map.',
      parameters: [
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.meta.stats': {
      label: 'apoc.meta.stats',
      documentation:
        'Returns the metadata stored in the transactional database statistics.',
      parameters: [],
    },
    'apoc.meta.subGraph': {
      label: 'apoc.meta.subGraph',
      documentation: 'Examines the given sub-graph and returns a meta-graph.',
      parameters: [
        {
          label: 'config',
          documentation: 'config :: MAP?',
        },
      ],
    },
    'apoc.neighbors.athop': {
      label: 'apoc.neighbors.athop',
      documentation:
        'Returns all nodes connected by the given relationship types at the specified distance.',
      parameters: [
        {
          label: 'node',
          documentation: 'node :: NODE?',
        },
        {
          label: 'relTypes',
          documentation: 'relTypes =  :: STRING?',
        },
        {
          label: 'distance',
          documentation: 'distance = 1 :: INTEGER?',
        },
      ],
    },
    'apoc.neighbors.athop.count': {
      label: 'apoc.neighbors.athop.count',
      documentation:
        'Returns the count of all nodes connected by the given relationship types at the specified distance.',
      parameters: [
        {
          label: 'node',
          documentation: 'node :: NODE?',
        },
        {
          label: 'relTypes',
          documentation: 'relTypes =  :: STRING?',
        },
        {
          label: 'distance',
          documentation: 'distance = 1 :: INTEGER?',
        },
      ],
    },
    'apoc.neighbors.byhop': {
      label: 'apoc.neighbors.byhop',
      documentation:
        'Returns all nodes connected by the given relationship types within the specified distance.',
      parameters: [
        {
          label: 'node',
          documentation: 'node :: NODE?',
        },
        {
          label: 'relTypes',
          documentation: 'relTypes =  :: STRING?',
        },
        {
          label: 'distance',
          documentation: 'distance = 1 :: INTEGER?',
        },
      ],
    },
    'apoc.neighbors.byhop.count': {
      label: 'apoc.neighbors.byhop.count',
      documentation:
        'Returns the count of all nodes connected by the given relationship types within the specified distance.',
      parameters: [
        {
          label: 'node',
          documentation: 'node :: NODE?',
        },
        {
          label: 'relTypes',
          documentation: 'relTypes =  :: STRING?',
        },
        {
          label: 'distance',
          documentation: 'distance = 1 :: INTEGER?',
        },
      ],
    },
    'apoc.neighbors.tohop': {
      label: 'apoc.neighbors.tohop',
      documentation:
        'Returns all nodes connected by the given relationship types within the specified distance.\nNodes are returned individually for each row.',
      parameters: [
        {
          label: 'node',
          documentation: 'node :: NODE?',
        },
        {
          label: 'relTypes',
          documentation: 'relTypes =  :: STRING?',
        },
        {
          label: 'distance',
          documentation: 'distance = 1 :: INTEGER?',
        },
      ],
    },
    'apoc.neighbors.tohop.count': {
      label: 'apoc.neighbors.tohop.count',
      documentation:
        'Returns the count of all nodes connected by the given relationships in the pattern within the specified distance.',
      parameters: [
        {
          label: 'node',
          documentation: 'node :: NODE?',
        },
        {
          label: 'relTypes',
          documentation: 'relTypes =  :: STRING?',
        },
        {
          label: 'distance',
          documentation: 'distance = 1 :: INTEGER?',
        },
      ],
    },
    'apoc.nodes.collapse': {
      label: 'apoc.nodes.collapse',
      documentation:
        'Merges nodes together in the given list.\nThe nodes are then combined to become one node, with all labels of the previous nodes attached to it, and all relationships pointing to it.',
      parameters: [
        {
          label: 'nodes',
          documentation: 'nodes :: LIST? OF NODE?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.nodes.cycles': {
      label: 'apoc.nodes.cycles',
      documentation:
        'Detects all path cycles in the given node list.\nThis procedure can be limited on relationships as well.',
      parameters: [
        {
          label: 'nodes',
          documentation: 'nodes :: LIST? OF NODE?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.nodes.delete': {
      label: 'apoc.nodes.delete',
      documentation: 'Deletes all nodes with the given ids.',
      parameters: [
        {
          label: 'nodes',
          documentation: 'nodes :: ANY?',
        },
        {
          label: 'batchSize',
          documentation: 'batchSize :: INTEGER?',
        },
      ],
    },
    'apoc.nodes.get': {
      label: 'apoc.nodes.get',
      documentation: 'Returns all nodes with the given ids.',
      parameters: [
        {
          label: 'nodes',
          documentation: 'nodes :: ANY?',
        },
      ],
    },
    'apoc.nodes.group': {
      label: 'apoc.nodes.group',
      documentation:
        'Allows for the aggregation of nodes based on the given properties.\nThis procedure returns virtual nodes.',
      parameters: [
        {
          label: 'labels',
          documentation: 'labels :: LIST? OF STRING?',
        },
        {
          label: 'groupByProperties',
          documentation: 'groupByProperties :: LIST? OF STRING?',
        },
        {
          label: 'aggregations',
          documentation:
            'aggregations = [{*=count}, {*=count}] :: LIST? OF MAP?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.nodes.link': {
      label: 'apoc.nodes.link',
      documentation:
        'Creates a linked list of the given nodes connected by the given relationship type.',
      parameters: [
        {
          label: 'nodes',
          documentation: 'nodes :: LIST? OF NODE?',
        },
        {
          label: 'type',
          documentation: 'type :: STRING?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.nodes.rels': {
      label: 'apoc.nodes.rels',
      documentation: 'Returns all relationships with the given ids.',
      parameters: [
        {
          label: 'rels',
          documentation: 'rels :: ANY?',
        },
      ],
    },
    'apoc.path.expand': {
      label: 'apoc.path.expand',
      documentation:
        'Returns paths expanded from the start node following the given relationship types from min-depth to max-depth.',
      parameters: [
        {
          label: 'startNode',
          documentation: 'startNode :: ANY?',
        },
        {
          label: 'relFilter',
          documentation: 'relFilter :: STRING?',
        },
        {
          label: 'labelFilter',
          documentation: 'labelFilter :: STRING?',
        },
        {
          label: 'minDepth',
          documentation: 'minDepth :: INTEGER?',
        },
        {
          label: 'maxDepth',
          documentation: 'maxDepth :: INTEGER?',
        },
      ],
    },
    'apoc.path.expandConfig': {
      label: 'apoc.path.expandConfig',
      documentation:
        'Returns paths expanded from the start node the given relationship types from min-depth to max-depth.',
      parameters: [
        {
          label: 'startNode',
          documentation: 'startNode :: ANY?',
        },
        {
          label: 'config',
          documentation: 'config :: MAP?',
        },
      ],
    },
    'apoc.path.spanningTree': {
      label: 'apoc.path.spanningTree',
      documentation:
        'Returns spanning tree paths expanded from the start node following the given relationship types to max-depth.',
      parameters: [
        {
          label: 'startNode',
          documentation: 'startNode :: ANY?',
        },
        {
          label: 'config',
          documentation: 'config :: MAP?',
        },
      ],
    },
    'apoc.path.subgraphAll': {
      label: 'apoc.path.subgraphAll',
      documentation:
        'Returns the sub-graph reachable from the start node following the given relationship types to max-depth.',
      parameters: [
        {
          label: 'startNode',
          documentation: 'startNode :: ANY?',
        },
        {
          label: 'config',
          documentation: 'config :: MAP?',
        },
      ],
    },
    'apoc.path.subgraphNodes': {
      label: 'apoc.path.subgraphNodes',
      documentation:
        'Returns the nodes in the sub-graph reachable from the start node following the given relationship types to max-depth.',
      parameters: [
        {
          label: 'startNode',
          documentation: 'startNode :: ANY?',
        },
        {
          label: 'config',
          documentation: 'config :: MAP?',
        },
      ],
    },
    'apoc.periodic.cancel': {
      label: 'apoc.periodic.cancel',
      documentation: 'Cancels the given background job.',
      parameters: [
        {
          label: 'name',
          documentation: 'name :: STRING?',
        },
      ],
    },
    'apoc.periodic.commit': {
      label: 'apoc.periodic.commit',
      documentation:
        'Runs the given statement in separate batched transactions.',
      parameters: [
        {
          label: 'statement',
          documentation: 'statement :: STRING?',
        },
        {
          label: 'params',
          documentation: 'params = {} :: MAP?',
        },
      ],
    },
    'apoc.periodic.countdown': {
      label: 'apoc.periodic.countdown',
      documentation:
        'Runs a repeatedly called background statement until it returns 0.',
      parameters: [
        {
          label: 'name',
          documentation: 'name :: STRING?',
        },
        {
          label: 'statement',
          documentation: 'statement :: STRING?',
        },
        {
          label: 'rate',
          documentation: 'rate :: INTEGER?',
        },
      ],
    },
    'apoc.periodic.iterate': {
      label: 'apoc.periodic.iterate',
      documentation:
        'Runs the second statement for each item returned by the first statement.\nThis procedure returns the number of batches and the total number of processed rows.',
      parameters: [
        {
          label: 'cypherIterate',
          documentation: 'cypherIterate :: STRING?',
        },
        {
          label: 'cypherAction',
          documentation: 'cypherAction :: STRING?',
        },
        {
          label: 'config',
          documentation: 'config :: MAP?',
        },
      ],
    },
    'apoc.periodic.list': {
      label: 'apoc.periodic.list',
      documentation: 'Returns a list of all background jobs.',
      parameters: [],
    },
    'apoc.periodic.repeat': {
      label: 'apoc.periodic.repeat',
      documentation:
        'Runs a repeatedly called background job.\nTo stop this procedure, use `apoc.periodic.cancel`.',
      parameters: [
        {
          label: 'name',
          documentation: 'name :: STRING?',
        },
        {
          label: 'statement',
          documentation: 'statement :: STRING?',
        },
        {
          label: 'rate',
          documentation: 'rate :: INTEGER?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.periodic.submit': {
      label: 'apoc.periodic.submit',
      documentation:
        'Creates a background job which runs the given Cypher statement once.',
      parameters: [
        {
          label: 'name',
          documentation: 'name :: STRING?',
        },
        {
          label: 'statement',
          documentation: 'statement :: STRING?',
        },
        {
          label: 'params',
          documentation: 'params = {} :: MAP?',
        },
      ],
    },
    'apoc.periodic.truncate': {
      label: 'apoc.periodic.truncate',
      documentation:
        'Removes all entities (and optionally indexes and constraints) from the database using the `apoc.periodic.iterate` procedure.',
      parameters: [
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.refactor.categorize': {
      label: 'apoc.refactor.categorize',
      documentation:
        'Creates new category nodes from nodes in the graph with the specified sourceKey as one of its property keys.\nThe new category nodes are then connected to the original nodes with a relationship of the given type.',
      parameters: [
        {
          label: 'sourceKey',
          documentation: 'sourceKey :: STRING?',
        },
        {
          label: 'type',
          documentation: 'type :: STRING?',
        },
        {
          label: 'outgoing',
          documentation: 'outgoing :: BOOLEAN?',
        },
        {
          label: 'label',
          documentation: 'label :: STRING?',
        },
        {
          label: 'targetKey',
          documentation: 'targetKey :: STRING?',
        },
        {
          label: 'copiedKeys',
          documentation: 'copiedKeys :: LIST? OF STRING?',
        },
        {
          label: 'batchSize',
          documentation: 'batchSize :: INTEGER?',
        },
      ],
    },
    'apoc.refactor.cloneNodes': {
      label: 'apoc.refactor.cloneNodes',
      documentation:
        'Clones the given nodes with their labels and properties.\nIt is possible to skip any node properties using skipProperties (note: this only skips properties on nodes and not their relationships).',
      parameters: [
        {
          label: 'nodes',
          documentation: 'nodes :: LIST? OF NODE?',
        },
        {
          label: 'withRelationships',
          documentation: 'withRelationships = false :: BOOLEAN?',
        },
        {
          label: 'skipProperties',
          documentation: 'skipProperties = [] :: LIST? OF STRING?',
        },
      ],
    },
    'apoc.refactor.cloneSubgraph': {
      label: 'apoc.refactor.cloneSubgraph',
      documentation:
        'Clones the given nodes with their labels and properties (optionally skipping any properties in the skipProperties list via the config map), and clones the given relationships.\nIf no relationships are provided, all existing relationships between the given nodes will be cloned.',
      parameters: [
        {
          label: 'nodes',
          documentation: 'nodes :: LIST? OF NODE?',
        },
        {
          label: 'rels',
          documentation: 'rels = [] :: LIST? OF RELATIONSHIP?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.refactor.cloneSubgraphFromPaths': {
      label: 'apoc.refactor.cloneSubgraphFromPaths',
      documentation:
        'Clones a sub-graph defined by the given list of paths.\nIt is possible to skip any node properties using the skipProperties list via the config map.',
      parameters: [
        {
          label: 'paths',
          documentation: 'paths :: LIST? OF PATH?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.refactor.collapseNode': {
      label: 'apoc.refactor.collapseNode',
      documentation:
        'Collapses the given node and replaces it with a relationship of the given type.',
      parameters: [
        {
          label: 'nodes',
          documentation: 'nodes :: ANY?',
        },
        {
          label: 'relType',
          documentation: 'relType :: STRING?',
        },
      ],
    },
    'apoc.refactor.deleteAndReconnect': {
      label: 'apoc.refactor.deleteAndReconnect',
      documentation:
        'Removes the given nodes from the path and reconnects the remaining nodes.',
      parameters: [
        {
          label: 'path',
          documentation: 'path :: PATH?',
        },
        {
          label: 'nodes',
          documentation: 'nodes :: LIST? OF NODE?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.refactor.extractNode': {
      label: 'apoc.refactor.extractNode',
      documentation:
        "Expands the given relationships into intermediate nodes.\nThe intermediate nodes are connected by the given 'OUT' and 'IN' types.",
      parameters: [
        {
          label: 'rels',
          documentation: 'rels :: ANY?',
        },
        {
          label: 'labels',
          documentation: 'labels :: LIST? OF STRING?',
        },
        {
          label: 'outType',
          documentation: 'outType :: STRING?',
        },
        {
          label: 'inType',
          documentation: 'inType :: STRING?',
        },
      ],
    },
    'apoc.refactor.from': {
      label: 'apoc.refactor.from',
      documentation:
        'Redirects the given relationship to the given start node.',
      parameters: [
        {
          label: 'rel',
          documentation: 'rel :: RELATIONSHIP?',
        },
        {
          label: 'newNode',
          documentation: 'newNode :: NODE?',
        },
      ],
    },
    'apoc.refactor.invert': {
      label: 'apoc.refactor.invert',
      documentation: 'Inverts the direction of the given relationship.',
      parameters: [
        {
          label: 'rel',
          documentation: 'rel :: RELATIONSHIP?',
        },
      ],
    },
    'apoc.refactor.mergeNodes': {
      label: 'apoc.refactor.mergeNodes',
      documentation:
        'Merges the given list of nodes onto the first node in the list.\nAll relationships are merged onto that node as well.',
      parameters: [
        {
          label: 'nodes',
          documentation: 'nodes :: LIST? OF NODE?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.refactor.mergeRelationships': {
      label: 'apoc.refactor.mergeRelationships',
      documentation:
        'Merges the given list of relationships onto the first relationship in the list.',
      parameters: [
        {
          label: 'rels',
          documentation: 'rels :: LIST? OF RELATIONSHIP?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.refactor.normalizeAsBoolean': {
      label: 'apoc.refactor.normalizeAsBoolean',
      documentation: 'Refactors the given property to a boolean.',
      parameters: [
        {
          label: 'entity',
          documentation: 'entity :: ANY?',
        },
        {
          label: 'propertyKey',
          documentation: 'propertyKey :: STRING?',
        },
        {
          label: 'trueValues',
          documentation: 'trueValues :: LIST? OF ANY?',
        },
        {
          label: 'falseValues',
          documentation: 'falseValues :: LIST? OF ANY?',
        },
      ],
    },
    'apoc.refactor.rename.label': {
      label: 'apoc.refactor.rename.label',
      documentation:
        "Renames the given label from 'oldLabel' to 'newLabel' for all nodes.\nIf a list of nodes is provided, the renaming is applied to the nodes within this list only.",
      parameters: [
        {
          label: 'oldLabel',
          documentation: 'oldLabel :: STRING?',
        },
        {
          label: 'newLabel',
          documentation: 'newLabel :: STRING?',
        },
        {
          label: 'nodes',
          documentation: 'nodes = [] :: LIST? OF NODE?',
        },
      ],
    },
    'apoc.refactor.rename.nodeProperty': {
      label: 'apoc.refactor.rename.nodeProperty',
      documentation:
        "Renames the given property from 'oldName' to 'newName' for all nodes.\nIf a list of nodes is provided, the renaming is applied to the nodes within this list only.",
      parameters: [
        {
          label: 'oldName',
          documentation: 'oldName :: STRING?',
        },
        {
          label: 'newName',
          documentation: 'newName :: STRING?',
        },
        {
          label: 'nodes',
          documentation: 'nodes = [] :: LIST? OF NODE?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.refactor.rename.type': {
      label: 'apoc.refactor.rename.type',
      documentation:
        "Renames all relationships with type 'oldType' to 'newType'.\nIf a list of relationships is provided, the renaming is applied to the relationships within this list only.",
      parameters: [
        {
          label: 'oldType',
          documentation: 'oldType :: STRING?',
        },
        {
          label: 'newType',
          documentation: 'newType :: STRING?',
        },
        {
          label: 'rels',
          documentation: 'rels = [] :: LIST? OF RELATIONSHIP?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.refactor.rename.typeProperty': {
      label: 'apoc.refactor.rename.typeProperty',
      documentation:
        "Renames the given property from 'oldName' to 'newName' for all relationships.\nIf a list of relationships is provided, the renaming is applied to the relationships within this list only.",
      parameters: [
        {
          label: 'oldName',
          documentation: 'oldName :: STRING?',
        },
        {
          label: 'newName',
          documentation: 'newName :: STRING?',
        },
        {
          label: 'rels',
          documentation: 'rels = [] :: LIST? OF RELATIONSHIP?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.refactor.setType': {
      label: 'apoc.refactor.setType',
      documentation: 'Changes the type of the given relationship.',
      parameters: [
        {
          label: 'rel',
          documentation: 'rel :: RELATIONSHIP?',
        },
        {
          label: 'newType',
          documentation: 'newType :: STRING?',
        },
      ],
    },
    'apoc.refactor.to': {
      label: 'apoc.refactor.to',
      documentation: 'Redirects the given relationship to the given end node.',
      parameters: [
        {
          label: 'rel',
          documentation: 'rel :: RELATIONSHIP?',
        },
        {
          label: 'endNode',
          documentation: 'endNode :: NODE?',
        },
      ],
    },
    'apoc.schema.assert': {
      label: 'apoc.schema.assert',
      documentation:
        'Drops all other existing indexes and constraints when `dropExisting` is `true` (default is `true`).\nAsserts at the end of the operation that the given indexes and unique constraints are there.',
      parameters: [
        {
          label: 'indexes',
          documentation: 'indexes :: MAP?',
        },
        {
          label: 'constraints',
          documentation: 'constraints :: MAP?',
        },
        {
          label: 'dropExisting',
          documentation: 'dropExisting = true :: BOOLEAN?',
        },
      ],
    },
    'apoc.schema.nodes': {
      label: 'apoc.schema.nodes',
      documentation:
        'Returns all indexes and constraints information for all node labels in the database.\nIt is possible to define a set of labels to include or exclude in the config parameters.',
      parameters: [
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.schema.properties.distinct': {
      label: 'apoc.schema.properties.distinct',
      documentation:
        'Returns all distinct node property values for the given key.',
      parameters: [
        {
          label: 'label',
          documentation: 'label :: STRING?',
        },
        {
          label: 'key',
          documentation: 'key :: STRING?',
        },
      ],
    },
    'apoc.schema.properties.distinctCount': {
      label: 'apoc.schema.properties.distinctCount',
      documentation:
        'Returns all distinct property values and counts for the given key.',
      parameters: [
        {
          label: 'label',
          documentation: 'label =  :: STRING?',
        },
        {
          label: 'key',
          documentation: 'key =  :: STRING?',
        },
      ],
    },
    'apoc.schema.relationships': {
      label: 'apoc.schema.relationships',
      documentation:
        'Returns the indexes and constraints information for all the relationship types in the database.\nIt is possible to define a set of relationship types to include or exclude in the config parameters.',
      parameters: [
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.search.multiSearchReduced': {
      label: 'apoc.search.multiSearchReduced',
      documentation:
        'Returns a reduced representation of the nodes found after a parallel search over multiple indexes.\nThe reduced node representation includes: node id, node labels and the searched properties.',
      parameters: [
        {
          label: 'labelPropertyMap',
          documentation: 'labelPropertyMap :: ANY?',
        },
        {
          label: 'operator',
          documentation: 'operator :: STRING?',
        },
        {
          label: 'value',
          documentation: 'value :: STRING?',
        },
      ],
    },
    'apoc.search.node': {
      label: 'apoc.search.node',
      documentation:
        'Returns all the distinct nodes found after a parallel search over multiple indexes.',
      parameters: [
        {
          label: 'labelPropertyMap',
          documentation: 'labelPropertyMap :: ANY?',
        },
        {
          label: 'operator',
          documentation: 'operator :: STRING?',
        },
        {
          label: 'value',
          documentation: 'value :: STRING?',
        },
      ],
    },
    'apoc.search.nodeAll': {
      label: 'apoc.search.nodeAll',
      documentation:
        'Returns all the nodes found after a parallel search over multiple indexes.',
      parameters: [
        {
          label: 'labelPropertyMap',
          documentation: 'labelPropertyMap :: ANY?',
        },
        {
          label: 'operator',
          documentation: 'operator :: STRING?',
        },
        {
          label: 'value',
          documentation: 'value :: STRING?',
        },
      ],
    },
    'apoc.search.nodeAllReduced': {
      label: 'apoc.search.nodeAllReduced',
      documentation:
        'Returns a reduced representation of the nodes found after a parallel search over multiple indexes.\nThe reduced node representation includes: node id, node labels and the searched properties.',
      parameters: [
        {
          label: 'labelPropertyMap',
          documentation: 'labelPropertyMap :: ANY?',
        },
        {
          label: 'operator',
          documentation: 'operator :: STRING?',
        },
        {
          label: 'value',
          documentation: 'value :: ANY?',
        },
      ],
    },
    'apoc.search.nodeReduced': {
      label: 'apoc.search.nodeReduced',
      documentation:
        'Returns a reduced representation of the distinct nodes found after a parallel search over multiple indexes.\nThe reduced node representation includes: node id, node labels and the searched properties.',
      parameters: [
        {
          label: 'labelPropertyMap',
          documentation: 'labelPropertyMap :: ANY?',
        },
        {
          label: 'operator',
          documentation: 'operator :: STRING?',
        },
        {
          label: 'value',
          documentation: 'value :: STRING?',
        },
      ],
    },
    'apoc.spatial.geocode': {
      label: 'apoc.spatial.geocode',
      documentation:
        'Returns the geographic location (latitude, longitude, and description) of the given address using a geocoding service (default: OpenStreetMap).',
      parameters: [
        {
          label: 'location',
          documentation: 'location :: STRING?',
        },
        {
          label: 'maxResults',
          documentation: 'maxResults = 100 :: INTEGER?',
        },
        {
          label: 'quotaException',
          documentation: 'quotaException = false :: BOOLEAN?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.spatial.geocodeOnce': {
      label: 'apoc.spatial.geocodeOnce',
      documentation:
        'Returns the geographic location (latitude, longitude, and description) of the given address using a geocoding service (default: OpenStreetMap).\nThis procedure returns at most one result.',
      parameters: [
        {
          label: 'location',
          documentation: 'location :: STRING?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.spatial.reverseGeocode': {
      label: 'apoc.spatial.reverseGeocode',
      documentation:
        'Returns a textual address from the given geographic location (latitude, longitude) using a geocoding service (default: OpenStreetMap).\nThis procedure returns at most one result.',
      parameters: [
        {
          label: 'latitude',
          documentation: 'latitude :: FLOAT?',
        },
        {
          label: 'longitude',
          documentation: 'longitude :: FLOAT?',
        },
        {
          label: 'quotaException',
          documentation: 'quotaException = false :: BOOLEAN?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.spatial.sortByDistance': {
      label: 'apoc.spatial.sortByDistance',
      documentation:
        'Sorts the given collection of paths by the sum of their distance based on the latitude/longitude values on the nodes.',
      parameters: [
        {
          label: 'paths',
          documentation: 'paths :: LIST? OF PATH?',
        },
      ],
    },
    'apoc.stats.degrees': {
      label: 'apoc.stats.degrees',
      documentation:
        'Returns the percentile groupings of the degrees on the nodes connected by the given relationship types.',
      parameters: [
        {
          label: 'relTypes',
          documentation: 'relTypes =  :: STRING?',
        },
      ],
    },
    'apoc.text.phoneticDelta': {
      label: 'apoc.text.phoneticDelta',
      documentation:
        'Returns the US_ENGLISH soundex character difference between the two given strings.',
      parameters: [
        {
          label: 'text1',
          documentation: 'text1 :: STRING?',
        },
        {
          label: 'text2',
          documentation: 'text2 :: STRING?',
        },
      ],
    },
    'apoc.trigger.add': {
      label: 'apoc.trigger.add',
      documentation:
        "Adds a trigger to the given Cypher statement.\nThe selector for this procedure is {phase:'before/after/rollback/afterAsync'}.",
      parameters: [
        {
          label: 'name',
          documentation: 'name :: STRING?',
        },
        {
          label: 'statement',
          documentation: 'statement :: STRING?',
        },
        {
          label: 'selector',
          documentation: 'selector :: MAP?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.trigger.drop': {
      label: 'apoc.trigger.drop',
      documentation: 'Eventually removes the given trigger.',
      parameters: [
        {
          label: 'databaseName',
          documentation: 'databaseName :: STRING?',
        },
        {
          label: 'name',
          documentation: 'name :: STRING?',
        },
      ],
    },
    'apoc.trigger.dropAll': {
      label: 'apoc.trigger.dropAll',
      documentation: 'Eventually removes all triggers from the given database.',
      parameters: [
        {
          label: 'databaseName',
          documentation: 'databaseName :: STRING?',
        },
      ],
    },
    'apoc.trigger.install': {
      label: 'apoc.trigger.install',
      documentation:
        'Eventually adds a trigger for a given database which is invoked when a successful transaction occurs.',
      parameters: [
        {
          label: 'databaseName',
          documentation: 'databaseName :: STRING?',
        },
        {
          label: 'name',
          documentation: 'name :: STRING?',
        },
        {
          label: 'statement',
          documentation: 'statement :: STRING?',
        },
        {
          label: 'selector',
          documentation: 'selector :: MAP?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'apoc.trigger.list': {
      label: 'apoc.trigger.list',
      documentation:
        'Lists all currently installed triggers for the session database.',
      parameters: [],
    },
    'apoc.trigger.pause': {
      label: 'apoc.trigger.pause',
      documentation: 'Pauses the given trigger.',
      parameters: [
        {
          label: 'name',
          documentation: 'name :: STRING?',
        },
      ],
    },
    'apoc.trigger.remove': {
      label: 'apoc.trigger.remove',
      documentation: 'Removes the given trigger.',
      parameters: [
        {
          label: 'name',
          documentation: 'name :: STRING?',
        },
      ],
    },
    'apoc.trigger.removeAll': {
      label: 'apoc.trigger.removeAll',
      documentation: 'Removes all previously added triggers.',
      parameters: [],
    },
    'apoc.trigger.resume': {
      label: 'apoc.trigger.resume',
      documentation: 'Resumes the given paused trigger.',
      parameters: [
        {
          label: 'name',
          documentation: 'name :: STRING?',
        },
      ],
    },
    'apoc.trigger.show': {
      label: 'apoc.trigger.show',
      documentation: 'Lists all eventually installed triggers for a database.',
      parameters: [
        {
          label: 'databaseName',
          documentation: 'databaseName :: STRING?',
        },
      ],
    },
    'apoc.trigger.start': {
      label: 'apoc.trigger.start',
      documentation: 'Eventually restarts the given paused trigger.',
      parameters: [
        {
          label: 'databaseName',
          documentation: 'databaseName :: STRING?',
        },
        {
          label: 'name',
          documentation: 'name :: STRING?',
        },
      ],
    },
    'apoc.trigger.stop': {
      label: 'apoc.trigger.stop',
      documentation: 'Eventually stops the given trigger.',
      parameters: [
        {
          label: 'databaseName',
          documentation: 'databaseName :: STRING?',
        },
        {
          label: 'name',
          documentation: 'name :: STRING?',
        },
      ],
    },
    'apoc.util.sleep': {
      label: 'apoc.util.sleep',
      documentation:
        'Causes the currently running Cypher to sleep for the given duration of milliseconds (the transaction termination is honored).',
      parameters: [
        {
          label: 'duration',
          documentation: 'duration :: INTEGER?',
        },
      ],
    },
    'apoc.util.validate': {
      label: 'apoc.util.validate',
      documentation: 'If the given predicate is true an exception is thrown.',
      parameters: [
        {
          label: 'predicate',
          documentation: 'predicate :: BOOLEAN?',
        },
        {
          label: 'message',
          documentation: 'message :: STRING?',
        },
        {
          label: 'params',
          documentation: 'params :: LIST? OF ANY?',
        },
      ],
    },
    'apoc.warmup.run': {
      label: 'apoc.warmup.run',
      documentation:
        'Loads all nodes and relationships in the database into memory.',
      parameters: [
        {
          label: 'loadProperties',
          documentation: 'loadProperties = false :: BOOLEAN?',
        },
        {
          label: 'loadDynamicProperties',
          documentation: 'loadDynamicProperties = false :: BOOLEAN?',
        },
        {
          label: 'loadIndexes',
          documentation: 'loadIndexes = false :: BOOLEAN?',
        },
      ],
    },
    'apoc.when': {
      label: 'apoc.when',
      documentation:
        'This procedure will run the read-only ifQuery if the conditional has evaluated to true, otherwise the elseQuery will run.',
      parameters: [
        {
          label: 'condition',
          documentation: 'condition :: BOOLEAN?',
        },
        {
          label: 'ifQuery',
          documentation: 'ifQuery :: STRING?',
        },
        {
          label: 'elseQuery',
          documentation: 'elseQuery =  :: STRING?',
        },
        {
          label: 'params',
          documentation: 'params = {} :: MAP?',
        },
      ],
    },
    'db.awaitIndex': {
      label: 'db.awaitIndex',
      documentation:
        'Wait for an index to come online (for example: CALL db.awaitIndex("MyIndex", 300)).',
      parameters: [
        {
          label: 'indexName',
          documentation: 'indexName :: STRING?',
        },
        {
          label: 'timeOutSeconds',
          documentation: 'timeOutSeconds = 300 :: INTEGER?',
        },
      ],
    },
    'db.awaitIndexes': {
      label: 'db.awaitIndexes',
      documentation:
        'Wait for all indexes to come online (for example: CALL db.awaitIndexes(300)).',
      parameters: [
        {
          label: 'timeOutSeconds',
          documentation: 'timeOutSeconds = 300 :: INTEGER?',
        },
      ],
    },
    'db.checkpoint': {
      label: 'db.checkpoint',
      documentation:
        'Initiate and wait for a new check point, or wait any already on-going check point to complete. Note that this temporarily disables the `db.checkpoint.iops.limit` setting in order to make the check point complete faster. This might cause transaction throughput to degrade slightly, due to increased IO load.',
      parameters: [],
    },
    'db.clearQueryCaches': {
      label: 'db.clearQueryCaches',
      documentation: 'Clears all query caches.',
      parameters: [],
    },
    'db.create.setVectorProperty': {
      label: 'db.create.setVectorProperty',
      documentation:
        "Set a vector property on a given node in a more space efficient representation than Cypher's SET.",
      parameters: [
        {
          label: 'node',
          documentation: 'node :: NODE?',
        },
        {
          label: 'key',
          documentation: 'key :: STRING?',
        },
        {
          label: 'vector',
          documentation: 'vector :: LIST? OF FLOAT?',
        },
      ],
    },
    'db.createLabel': {
      label: 'db.createLabel',
      documentation: 'Create a label',
      parameters: [
        {
          label: 'newLabel',
          documentation: 'newLabel :: STRING?',
        },
      ],
    },
    'db.createProperty': {
      label: 'db.createProperty',
      documentation: 'Create a Property',
      parameters: [
        {
          label: 'newProperty',
          documentation: 'newProperty :: STRING?',
        },
      ],
    },
    'db.createRelationshipType': {
      label: 'db.createRelationshipType',
      documentation: 'Create a RelationshipType',
      parameters: [
        {
          label: 'newRelationshipType',
          documentation: 'newRelationshipType :: STRING?',
        },
      ],
    },
    'db.index.fulltext.awaitEventuallyConsistentIndexRefresh': {
      label: 'db.index.fulltext.awaitEventuallyConsistentIndexRefresh',
      documentation:
        'Wait for the updates from recently committed transactions to be applied to any eventually-consistent full-text indexes.',
      parameters: [],
    },
    'db.index.fulltext.listAvailableAnalyzers': {
      label: 'db.index.fulltext.listAvailableAnalyzers',
      documentation:
        'List the available analyzers that the full-text indexes can be configured with.',
      parameters: [],
    },
    'db.index.fulltext.queryNodes': {
      label: 'db.index.fulltext.queryNodes',
      documentation:
        "Query the given full-text index. Returns the matching nodes, and their Lucene query score, ordered by score. Valid keys for the options map are: 'skip' to skip the top N results; 'limit' to limit the number of results returned; 'analyzer' to use the specified analyzer as search analyzer for this query.",
      parameters: [
        {
          label: 'indexName',
          documentation: 'indexName :: STRING?',
        },
        {
          label: 'queryString',
          documentation: 'queryString :: STRING?',
        },
        {
          label: 'options',
          documentation: 'options = {} :: MAP?',
        },
      ],
    },
    'db.index.fulltext.queryRelationships': {
      label: 'db.index.fulltext.queryRelationships',
      documentation:
        "Query the given full-text index. Returns the matching relationships, and their Lucene query score, ordered by score. Valid keys for the options map are: 'skip' to skip the top N results; 'limit' to limit the number of results returned; 'analyzer' to use the specified analyzer as search analyzer for this query.",
      parameters: [
        {
          label: 'indexName',
          documentation: 'indexName :: STRING?',
        },
        {
          label: 'queryString',
          documentation: 'queryString :: STRING?',
        },
        {
          label: 'options',
          documentation: 'options = {} :: MAP?',
        },
      ],
    },
    'db.index.vector.createNodeIndex': {
      label: 'db.index.vector.createNodeIndex',
      documentation:
        "Create a named node vector index for the given label and property for a specified vector dimensionality.\nValid similarity functions are 'EUCLIDEAN' and 'COSINE', and are case-insensitive.\nUse the `db.index.vector.queryNodes` procedure to query the named index.\n",
      parameters: [
        {
          label: 'indexName',
          documentation: 'indexName :: STRING?',
        },
        {
          label: 'label',
          documentation: 'label :: STRING?',
        },
        {
          label: 'propertyKey',
          documentation: 'propertyKey :: STRING?',
        },
        {
          label: 'vectorDimension',
          documentation: 'vectorDimension :: INTEGER?',
        },
        {
          label: 'vectorSimilarityFunction',
          documentation: 'vectorSimilarityFunction :: STRING?',
        },
      ],
    },
    'db.index.vector.queryNodes': {
      label: 'db.index.vector.queryNodes',
      documentation:
        'Query the given vector index.\nReturns requested number of nearest neighbors to the provided query vector,\nand their similarity score to that query vector, based on the configured similarity function for the index.\nThe similarity score is a value between [0, 1]; where 0 indicates least similar, 1 most similar.\n',
      parameters: [
        {
          label: 'indexName',
          documentation: 'indexName :: STRING?',
        },
        {
          label: 'numberOfNearestNeighbours',
          documentation: 'numberOfNearestNeighbours :: INTEGER?',
        },
        {
          label: 'query',
          documentation: 'query :: LIST? OF FLOAT?',
        },
      ],
    },
    'db.info': {
      label: 'db.info',
      documentation: 'Provides information regarding the database.',
      parameters: [],
    },
    'db.labels': {
      label: 'db.labels',
      documentation: 'List all available labels in the database.',
      parameters: [],
    },
    'db.listLocks': {
      label: 'db.listLocks',
      documentation: 'List all locks at this database.',
      parameters: [],
    },
    'db.ping': {
      label: 'db.ping',
      documentation:
        'This procedure can be used by client side tooling to test whether they are correctly connected to a database. The procedure is available in all databases and always returns true. A faulty connection can be detected by not being able to call this procedure.',
      parameters: [],
    },
    'db.prepareForReplanning': {
      label: 'db.prepareForReplanning',
      documentation:
        'Triggers an index resample and waits for it to complete, and after that clears query caches. After this procedure has finished queries will be planned using the latest database statistics.',
      parameters: [
        {
          label: 'timeOutSeconds',
          documentation: 'timeOutSeconds = 300 :: INTEGER?',
        },
      ],
    },
    'db.propertyKeys': {
      label: 'db.propertyKeys',
      documentation: 'List all property keys in the database.',
      parameters: [],
    },
    'db.relationshipTypes': {
      label: 'db.relationshipTypes',
      documentation: 'List all available relationship types in the database.',
      parameters: [],
    },
    'db.resampleIndex': {
      label: 'db.resampleIndex',
      documentation:
        'Schedule resampling of an index (for example: CALL db.resampleIndex("MyIndex")).',
      parameters: [
        {
          label: 'indexName',
          documentation: 'indexName :: STRING?',
        },
      ],
    },
    'db.resampleOutdatedIndexes': {
      label: 'db.resampleOutdatedIndexes',
      documentation: 'Schedule resampling of all outdated indexes.',
      parameters: [],
    },
    'db.schema.nodeTypeProperties': {
      label: 'db.schema.nodeTypeProperties',
      documentation:
        'Show the derived property schema of the nodes in tabular form.',
      parameters: [],
    },
    'db.schema.relTypeProperties': {
      label: 'db.schema.relTypeProperties',
      documentation:
        'Show the derived property schema of the relationships in tabular form.',
      parameters: [],
    },
    'db.schema.visualization': {
      label: 'db.schema.visualization',
      documentation:
        'Visualizes the schema of the data based on available statistics. A new node is returned for each label. The properties represented on the node include: `name` (label name), `indexes` (list of indexes), and `constraints` (list of constraints). A relationship of a given type is returned for all possible combinations of start and end nodes. The properties represented on the relationship include: `name` (type name). Note that this may include additional relationships that do not exist in the data due to the information available in the count store. ',
      parameters: [],
    },
    'db.stats.clear': {
      label: 'db.stats.clear',
      documentation:
        "Clear collected data of a given data section. Valid sections are 'QUERIES'",
      parameters: [
        {
          label: 'section',
          documentation: 'section :: STRING?',
        },
      ],
    },
    'db.stats.collect': {
      label: 'db.stats.collect',
      documentation:
        "Start data collection of a given data section. Valid sections are 'QUERIES'",
      parameters: [
        {
          label: 'section',
          documentation: 'section :: STRING?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'db.stats.retrieve': {
      label: 'db.stats.retrieve',
      documentation:
        "Retrieve statistical data about the current database. Valid sections are 'GRAPH COUNTS', 'TOKENS', 'QUERIES', 'META'",
      parameters: [
        {
          label: 'section',
          documentation: 'section :: STRING?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'db.stats.retrieveAllAnonymized': {
      label: 'db.stats.retrieveAllAnonymized',
      documentation:
        'Retrieve all available statistical data about the current database, in an anonymized form.',
      parameters: [
        {
          label: 'graphToken',
          documentation: 'graphToken :: STRING?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'db.stats.status': {
      label: 'db.stats.status',
      documentation:
        'Retrieve the status of all available collector daemons, for this database.',
      parameters: [],
    },
    'db.stats.stop': {
      label: 'db.stats.stop',
      documentation:
        "Stop data collection of a given data section. Valid sections are 'QUERIES'",
      parameters: [
        {
          label: 'section',
          documentation: 'section :: STRING?',
        },
      ],
    },
    'dbms.checkConfigValue': {
      label: 'dbms.checkConfigValue',
      documentation: 'Check if a potential config setting value is valid.',
      parameters: [
        {
          label: 'setting',
          documentation: 'setting :: STRING?',
        },
        {
          label: 'value',
          documentation: 'value :: STRING?',
        },
      ],
    },
    'dbms.cluster.checkConnectivity': {
      label: 'dbms.cluster.checkConnectivity',
      documentation:
        "Check the connectivity of this instance to other cluster members. Not all ports are relevant to all members. Valid values for 'port-name' are: [CLUSTER, RAFT]",
      parameters: [
        {
          label: 'port-name',
          documentation: 'port-name = null :: STRING?',
        },
        {
          label: 'server',
          documentation: 'server = null :: STRING?',
        },
      ],
    },
    'dbms.cluster.cordonServer': {
      label: 'dbms.cluster.cordonServer',
      documentation:
        'Mark a server in the topology as not suitable for new allocations. It will not force current allocations off the server. This is useful when deallocating databases when you have multiple unavailable servers.',
      parameters: [
        {
          label: 'server',
          documentation: 'server :: STRING?',
        },
      ],
    },
    'dbms.cluster.protocols': {
      label: 'dbms.cluster.protocols',
      documentation: 'Overview of installed protocols',
      parameters: [],
    },
    'dbms.cluster.readReplicaToggle': {
      label: 'dbms.cluster.readReplicaToggle',
      documentation:
        'The toggle can pause or resume read replica (deprecated in favor of dbms.cluster.secondaryReplicationDisable)',
      parameters: [
        {
          label: 'databaseName',
          documentation: 'databaseName :: STRING?',
        },
        {
          label: 'pause',
          documentation: 'pause :: BOOLEAN?',
        },
      ],
    },
    'dbms.cluster.routing.getRoutingTable': {
      label: 'dbms.cluster.routing.getRoutingTable',
      documentation:
        "Returns the advertised bolt capable endpoints for a given database, divided by each endpoint's capabilities. For example an endpoint may serve read queries, write queries and/or future getRoutingTable requests.",
      parameters: [
        {
          label: 'context',
          documentation: 'context :: MAP?',
        },
        {
          label: 'database',
          documentation: 'database = null :: STRING?',
        },
      ],
    },
    'dbms.cluster.secondaryReplicationDisable': {
      label: 'dbms.cluster.secondaryReplicationDisable',
      documentation:
        'The toggle can pause or resume the secondary replication process',
      parameters: [
        {
          label: 'databaseName',
          documentation: 'databaseName :: STRING?',
        },
        {
          label: 'pause',
          documentation: 'pause :: BOOLEAN?',
        },
      ],
    },
    'dbms.cluster.setAutomaticallyEnableFreeServers': {
      label: 'dbms.cluster.setAutomaticallyEnableFreeServers',
      documentation:
        'With this method you can set whether free servers are automatically enabled.',
      parameters: [
        {
          label: 'autoEnable',
          documentation: 'autoEnable :: BOOLEAN?',
        },
      ],
    },
    'dbms.cluster.uncordonServer': {
      label: 'dbms.cluster.uncordonServer',
      documentation:
        "Remove the cordon on a server, returning it to 'enabled'.",
      parameters: [
        {
          label: 'server',
          documentation: 'server :: STRING?',
        },
      ],
    },
    'dbms.components': {
      label: 'dbms.components',
      documentation: 'List DBMS components and their versions.',
      parameters: [],
    },
    'dbms.info': {
      label: 'dbms.info',
      documentation: 'Provides information regarding the DBMS.',
      parameters: [],
    },
    'dbms.killConnection': {
      label: 'dbms.killConnection',
      documentation: 'Kill network connection with the given connection id.',
      parameters: [
        {
          label: 'id',
          documentation: 'id :: STRING?',
        },
      ],
    },
    'dbms.killConnections': {
      label: 'dbms.killConnections',
      documentation:
        'Kill all network connections with the given connection ids.',
      parameters: [
        {
          label: 'ids',
          documentation: 'ids :: LIST? OF STRING?',
        },
      ],
    },
    'dbms.listActiveLocks': {
      label: 'dbms.listActiveLocks',
      documentation:
        'List the active lock requests granted for the transaction executing the query with the given query id.',
      parameters: [
        {
          label: 'queryId',
          documentation: 'queryId :: STRING?',
        },
      ],
    },
    'dbms.listCapabilities': {
      label: 'dbms.listCapabilities',
      documentation: 'List capabilities',
      parameters: [],
    },
    'dbms.listConfig': {
      label: 'dbms.listConfig',
      documentation: 'List the currently active config of Neo4j.',
      parameters: [
        {
          label: 'searchString',
          documentation: 'searchString =  :: STRING?',
        },
      ],
    },
    'dbms.listConnections': {
      label: 'dbms.listConnections',
      documentation:
        'List all accepted network connections at this instance that are visible to the user.',
      parameters: [],
    },
    'dbms.listPools': {
      label: 'dbms.listPools',
      documentation:
        'List all memory pools, including sub pools, currently registered at this instance that are visible to the user.',
      parameters: [],
    },
    'dbms.quarantineDatabase': {
      label: 'dbms.quarantineDatabase',
      documentation: 'Place a database into quarantine or remove from it.',
      parameters: [
        {
          label: 'databaseName',
          documentation: 'databaseName :: STRING?',
        },
        {
          label: 'setStatus',
          documentation: 'setStatus :: BOOLEAN?',
        },
        {
          label: 'reason',
          documentation: 'reason = No reason given :: STRING?',
        },
      ],
    },
    'dbms.queryJmx': {
      label: 'dbms.queryJmx',
      documentation:
        'Query JMX management data by domain and name. For instance, "*:*"',
      parameters: [
        {
          label: 'query',
          documentation: 'query :: STRING?',
        },
      ],
    },
    'dbms.routing.getRoutingTable': {
      label: 'dbms.routing.getRoutingTable',
      documentation:
        "Returns the advertised bolt capable endpoints for a given database, divided by each endpoint's capabilities. For example an endpoint may serve read queries, write queries and/or future getRoutingTable requests.",
      parameters: [
        {
          label: 'context',
          documentation: 'context :: MAP?',
        },
        {
          label: 'database',
          documentation: 'database = null :: STRING?',
        },
      ],
    },
    'dbms.scheduler.failedJobs': {
      label: 'dbms.scheduler.failedJobs',
      documentation:
        'List failed job runs. There is a limit for amount of historical data.',
      parameters: [],
    },
    'dbms.scheduler.groups': {
      label: 'dbms.scheduler.groups',
      documentation:
        'List the job groups that are active in the database internal job scheduler.',
      parameters: [],
    },
    'dbms.scheduler.jobs': {
      label: 'dbms.scheduler.jobs',
      documentation:
        'List all jobs that are active in the database internal job scheduler.',
      parameters: [],
    },
    'dbms.security.clearAuthCache': {
      label: 'dbms.security.clearAuthCache',
      documentation: 'Clears authentication and authorization cache.',
      parameters: [],
    },
    'dbms.setConfigValue': {
      label: 'dbms.setConfigValue',
      documentation:
        'Updates a given setting value. Passing an empty value will result in removing the configured value and falling back to the default value. Changes will not persist and will be lost if the server is restarted.',
      parameters: [
        {
          label: 'setting',
          documentation: 'setting :: STRING?',
        },
        {
          label: 'value',
          documentation: 'value :: STRING?',
        },
      ],
    },
    'dbms.setDatabaseAllocator': {
      label: 'dbms.setDatabaseAllocator',
      documentation:
        'With this method you can set the allocator, which is responsible to select servers for hosting databases.',
      parameters: [
        {
          label: 'allocator',
          documentation: 'allocator :: STRING?',
        },
      ],
    },
    'dbms.setDefaultAllocationNumbers': {
      label: 'dbms.setDefaultAllocationNumbers',
      documentation:
        'With this method you can set the default number of primaries and secondaries.',
      parameters: [
        {
          label: 'primaries',
          documentation: 'primaries :: INTEGER?',
        },
        {
          label: 'secondaries',
          documentation: 'secondaries :: INTEGER?',
        },
      ],
    },
    'dbms.setDefaultDatabase': {
      label: 'dbms.setDefaultDatabase',
      documentation:
        'Change the default database to the provided value. The database must exist and the old default database must be stopped.',
      parameters: [
        {
          label: 'databaseName',
          documentation: 'databaseName :: STRING?',
        },
      ],
    },
    'dbms.showCurrentUser': {
      label: 'dbms.showCurrentUser',
      documentation: 'Show the current user.',
      parameters: [],
    },
    'dbms.showTopologyGraphConfig': {
      label: 'dbms.showTopologyGraphConfig',
      documentation:
        'With this method the configuration of the Topology Graph can be displayed.',
      parameters: [],
    },
    'dbms.upgrade': {
      label: 'dbms.upgrade',
      documentation:
        'Upgrade the system database schema if it is not the current schema.',
      parameters: [],
    },
    'dbms.upgradeStatus': {
      label: 'dbms.upgradeStatus',
      documentation:
        'Report the current status of the system database sub-graph schema.',
      parameters: [],
    },
    'gds.allShortestPaths.delta.mutate': {
      label: 'gds.allShortestPaths.delta.mutate',
      documentation:
        'The Delta Stepping shortest path algorithm computes the shortest (weighted) path between one node and any other node in the graph. The computation is run multi-threaded',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.allShortestPaths.delta.mutate.estimate': {
      label: 'gds.allShortestPaths.delta.mutate.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.allShortestPaths.delta.stats': {
      label: 'gds.allShortestPaths.delta.stats',
      documentation:
        'The Delta Stepping shortest path algorithm computes the shortest (weighted) path between one node and any other node in the graph. The computation is run multi-threaded',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.allShortestPaths.delta.stats.estimate': {
      label: 'gds.allShortestPaths.delta.stats.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.allShortestPaths.delta.stream': {
      label: 'gds.allShortestPaths.delta.stream',
      documentation:
        'The Delta Stepping shortest path algorithm computes the shortest (weighted) path between one node and any other node in the graph. The computation is run multi-threaded',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.allShortestPaths.delta.stream.estimate': {
      label: 'gds.allShortestPaths.delta.stream.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.allShortestPaths.delta.write': {
      label: 'gds.allShortestPaths.delta.write',
      documentation:
        'The Delta Stepping shortest path algorithm computes the shortest (weighted) path between one node and any other node in the graph. The computation is run multi-threaded',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.allShortestPaths.delta.write.estimate': {
      label: 'gds.allShortestPaths.delta.write.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.allShortestPaths.dijkstra.mutate': {
      label: 'gds.allShortestPaths.dijkstra.mutate',
      documentation:
        'The Dijkstra shortest path algorithm computes the shortest (weighted) path between one node and any other node in the graph.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.allShortestPaths.dijkstra.mutate.estimate': {
      label: 'gds.allShortestPaths.dijkstra.mutate.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.allShortestPaths.dijkstra.stream': {
      label: 'gds.allShortestPaths.dijkstra.stream',
      documentation:
        'The Dijkstra shortest path algorithm computes the shortest (weighted) path between one node and any other node in the graph.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.allShortestPaths.dijkstra.stream.estimate': {
      label: 'gds.allShortestPaths.dijkstra.stream.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.allShortestPaths.dijkstra.write': {
      label: 'gds.allShortestPaths.dijkstra.write',
      documentation:
        'The Dijkstra shortest path algorithm computes the shortest (weighted) path between one node and any other node in the graph.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.allShortestPaths.dijkstra.write.estimate': {
      label: 'gds.allShortestPaths.dijkstra.write.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.allShortestPaths.stream': {
      label: 'gds.allShortestPaths.stream',
      documentation:
        'The All Pairs Shortest Path (APSP) calculates the shortest (weighted) path between all pairs of nodes.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.alpha.ml.splitRelationships.mutate': {
      label: 'gds.alpha.ml.splitRelationships.mutate',
      documentation:
        'Splits a graph into holdout and remaining relationship types and adds them to the graph.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.alpha.pipeline.linkPrediction.addMLP': {
      label: 'gds.alpha.pipeline.linkPrediction.addMLP',
      documentation:
        'Add a multilayer perceptron configuration to the parameter space of the link prediction train pipeline.',
      parameters: [
        {
          label: 'pipelineName',
          documentation: 'pipelineName :: STRING?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'gds.alpha.pipeline.linkPrediction.configureAutoTuning': {
      label: 'gds.alpha.pipeline.linkPrediction.configureAutoTuning',
      documentation:
        'Configures the auto-tuning of the link prediction pipeline.',
      parameters: [
        {
          label: 'pipelineName',
          documentation: 'pipelineName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration :: MAP?',
        },
      ],
    },
    'gds.alpha.pipeline.nodeClassification.addMLP': {
      label: 'gds.alpha.pipeline.nodeClassification.addMLP',
      documentation:
        'Add a multilayer perceptron configuration to the parameter space of the node classification train pipeline.',
      parameters: [
        {
          label: 'pipelineName',
          documentation: 'pipelineName :: STRING?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'gds.alpha.pipeline.nodeClassification.configureAutoTuning': {
      label: 'gds.alpha.pipeline.nodeClassification.configureAutoTuning',
      documentation:
        'Configures the auto-tuning of the node classification pipeline.',
      parameters: [
        {
          label: 'pipelineName',
          documentation: 'pipelineName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration :: MAP?',
        },
      ],
    },
    'gds.alpha.pipeline.nodeRegression.addLinearRegression': {
      label: 'gds.alpha.pipeline.nodeRegression.addLinearRegression',
      documentation:
        'Add a linear regression model candidate to a node regression pipeline.',
      parameters: [
        {
          label: 'pipelineName',
          documentation: 'pipelineName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.alpha.pipeline.nodeRegression.addNodeProperty': {
      label: 'gds.alpha.pipeline.nodeRegression.addNodeProperty',
      documentation:
        'Add a node property step to an existing node regression training pipeline.',
      parameters: [
        {
          label: 'pipelineName',
          documentation: 'pipelineName :: STRING?',
        },
        {
          label: 'procedureName',
          documentation: 'procedureName :: STRING?',
        },
        {
          label: 'procedureConfiguration',
          documentation: 'procedureConfiguration :: MAP?',
        },
      ],
    },
    'gds.alpha.pipeline.nodeRegression.addRandomForest': {
      label: 'gds.alpha.pipeline.nodeRegression.addRandomForest',
      documentation:
        'Add a random forest model candidate to a node regression pipeline.',
      parameters: [
        {
          label: 'pipelineName',
          documentation: 'pipelineName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration :: MAP?',
        },
      ],
    },
    'gds.alpha.pipeline.nodeRegression.configureAutoTuning': {
      label: 'gds.alpha.pipeline.nodeRegression.configureAutoTuning',
      documentation:
        'Configures the auto-tuning of a node regression pipeline.',
      parameters: [
        {
          label: 'pipelineName',
          documentation: 'pipelineName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration :: MAP?',
        },
      ],
    },
    'gds.alpha.pipeline.nodeRegression.configureSplit': {
      label: 'gds.alpha.pipeline.nodeRegression.configureSplit',
      documentation:
        'Configures the graph splitting of a node regression pipeline.',
      parameters: [
        {
          label: 'pipelineName',
          documentation: 'pipelineName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration :: MAP?',
        },
      ],
    },
    'gds.alpha.pipeline.nodeRegression.create': {
      label: 'gds.alpha.pipeline.nodeRegression.create',
      documentation:
        'Creates a node regression training pipeline in the pipeline catalog.',
      parameters: [
        {
          label: 'pipelineName',
          documentation: 'pipelineName :: STRING?',
        },
      ],
    },
    'gds.alpha.pipeline.nodeRegression.predict.mutate': {
      label: 'gds.alpha.pipeline.nodeRegression.predict.mutate',
      documentation:
        'Predicts target node property using a previously trained `NodeRegression` model',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.alpha.pipeline.nodeRegression.predict.stream': {
      label: 'gds.alpha.pipeline.nodeRegression.predict.stream',
      documentation:
        'Predicts target node property using a previously trained `NodeRegression` model',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration :: MAP?',
        },
      ],
    },
    'gds.alpha.pipeline.nodeRegression.selectFeatures': {
      label: 'gds.alpha.pipeline.nodeRegression.selectFeatures',
      documentation:
        'Add one or several features to an existing node regression training pipeline.',
      parameters: [
        {
          label: 'pipelineName',
          documentation: 'pipelineName :: STRING?',
        },
        {
          label: 'featureProperties',
          documentation: 'featureProperties :: ANY?',
        },
      ],
    },
    'gds.alpha.pipeline.nodeRegression.train': {
      label: 'gds.alpha.pipeline.nodeRegression.train',
      documentation: 'Trains a node classification model based on a pipeline',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.articleRank.mutate': {
      label: 'gds.articleRank.mutate',
      documentation:
        'Article Rank is a variant of the Page Rank algorithm, which measures the transitive influence or connectivity of nodes.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.articleRank.mutate.estimate': {
      label: 'gds.articleRank.mutate.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.articleRank.stats': {
      label: 'gds.articleRank.stats',
      documentation:
        'Executes the algorithm and returns result statistics without writing the result to Neo4j.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.articleRank.stats.estimate': {
      label: 'gds.articleRank.stats.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.articleRank.stream': {
      label: 'gds.articleRank.stream',
      documentation:
        'Article Rank is a variant of the Page Rank algorithm, which measures the transitive influence or connectivity of nodes.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.articleRank.stream.estimate': {
      label: 'gds.articleRank.stream.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.articleRank.write': {
      label: 'gds.articleRank.write',
      documentation:
        'Article Rank is a variant of the Page Rank algorithm, which measures the transitive influence or connectivity of nodes.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.articleRank.write.estimate': {
      label: 'gds.articleRank.write.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.backup': {
      label: 'gds.backup',
      documentation: 'The back-up procedure persists graphs and models to disk',
      parameters: [
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.bellmanFord.mutate': {
      label: 'gds.bellmanFord.mutate',
      documentation:
        'The Bellman-Ford shortest path algorithm computes the shortest (weighted) path between one node and any other node in the graph without negative cycles.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.bellmanFord.mutate.estimate': {
      label: 'gds.bellmanFord.mutate.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.bellmanFord.stats': {
      label: 'gds.bellmanFord.stats',
      documentation:
        'The Bellman-Ford shortest path algorithm computes the shortest (weighted) path between one node and any other node in the graph without negative cycles.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.bellmanFord.stats.estimate': {
      label: 'gds.bellmanFord.stats.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.bellmanFord.stream': {
      label: 'gds.bellmanFord.stream',
      documentation:
        'The Bellman-Ford shortest path algorithm computes the shortest (weighted) path between one node and any other node in the graph without negative cycles.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.bellmanFord.stream.estimate': {
      label: 'gds.bellmanFord.stream.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.bellmanFord.write': {
      label: 'gds.bellmanFord.write',
      documentation:
        'The Bellman-Ford shortest path algorithm computes the shortest (weighted) path between one node and any other node in the graph without negative cycles.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.bellmanFord.write.estimate': {
      label: 'gds.bellmanFord.write.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.beta.graphSage.mutate': {
      label: 'gds.beta.graphSage.mutate',
      documentation:
        'The GraphSage algorithm inductively computes embeddings for nodes based on a their features and neighborhoods.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.beta.graphSage.mutate.estimate': {
      label: 'gds.beta.graphSage.mutate.estimate',
      documentation:
        'The GraphSage algorithm inductively computes embeddings for nodes based on a their features and neighborhoods.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.beta.graphSage.stream': {
      label: 'gds.beta.graphSage.stream',
      documentation:
        'The GraphSage algorithm inductively computes embeddings for nodes based on a their features and neighborhoods.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.beta.graphSage.stream.estimate': {
      label: 'gds.beta.graphSage.stream.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.beta.graphSage.train': {
      label: 'gds.beta.graphSage.train',
      documentation:
        'The GraphSage algorithm inductively computes embeddings for nodes based on a their features and neighborhoods.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.beta.graphSage.train.estimate': {
      label: 'gds.beta.graphSage.train.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.beta.graphSage.write': {
      label: 'gds.beta.graphSage.write',
      documentation:
        'The GraphSage algorithm inductively computes embeddings for nodes based on a their features and neighborhoods.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.beta.graphSage.write.estimate': {
      label: 'gds.beta.graphSage.write.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.beta.pipeline.linkPrediction.addFeature': {
      label: 'gds.beta.pipeline.linkPrediction.addFeature',
      documentation:
        'Add a feature step to an existing link prediction pipeline.',
      parameters: [
        {
          label: 'pipelineName',
          documentation: 'pipelineName :: STRING?',
        },
        {
          label: 'featureType',
          documentation: 'featureType :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration :: MAP?',
        },
      ],
    },
    'gds.beta.pipeline.linkPrediction.addLogisticRegression': {
      label: 'gds.beta.pipeline.linkPrediction.addLogisticRegression',
      documentation:
        'Add a logistic regression configuration to the parameter space of the link prediction train pipeline.',
      parameters: [
        {
          label: 'pipelineName',
          documentation: 'pipelineName :: STRING?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'gds.beta.pipeline.linkPrediction.addNodeProperty': {
      label: 'gds.beta.pipeline.linkPrediction.addNodeProperty',
      documentation:
        'Add a node property step to an existing link prediction pipeline.',
      parameters: [
        {
          label: 'pipelineName',
          documentation: 'pipelineName :: STRING?',
        },
        {
          label: 'procedureName',
          documentation: 'procedureName :: STRING?',
        },
        {
          label: 'procedureConfiguration',
          documentation: 'procedureConfiguration :: MAP?',
        },
      ],
    },
    'gds.beta.pipeline.linkPrediction.addRandomForest': {
      label: 'gds.beta.pipeline.linkPrediction.addRandomForest',
      documentation:
        'Add a random forest configuration to the parameter space of the link prediction train pipeline.',
      parameters: [
        {
          label: 'pipelineName',
          documentation: 'pipelineName :: STRING?',
        },
        {
          label: 'config',
          documentation: 'config :: MAP?',
        },
      ],
    },
    'gds.beta.pipeline.linkPrediction.configureSplit': {
      label: 'gds.beta.pipeline.linkPrediction.configureSplit',
      documentation: 'Configures the split of the link prediction pipeline.',
      parameters: [
        {
          label: 'pipelineName',
          documentation: 'pipelineName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration :: MAP?',
        },
      ],
    },
    'gds.beta.pipeline.linkPrediction.create': {
      label: 'gds.beta.pipeline.linkPrediction.create',
      documentation:
        'Creates a link prediction pipeline in the pipeline catalog.',
      parameters: [
        {
          label: 'pipelineName',
          documentation: 'pipelineName :: STRING?',
        },
      ],
    },
    'gds.beta.pipeline.linkPrediction.predict.mutate': {
      label: 'gds.beta.pipeline.linkPrediction.predict.mutate',
      documentation:
        'Predicts relationships for all non-connected node pairs based on a previously trained LinkPrediction model.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.beta.pipeline.linkPrediction.predict.mutate.estimate': {
      label: 'gds.beta.pipeline.linkPrediction.predict.mutate.estimate',
      documentation:
        'Estimates memory for predicting relationships for all non-connected node pairs based on a previously trained LinkPrediction model',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.beta.pipeline.linkPrediction.predict.stream': {
      label: 'gds.beta.pipeline.linkPrediction.predict.stream',
      documentation:
        'Predicts relationships for all non-connected node pairs based on a previously trained LinkPrediction model.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.beta.pipeline.linkPrediction.predict.stream.estimate': {
      label: 'gds.beta.pipeline.linkPrediction.predict.stream.estimate',
      documentation:
        'Estimates memory for predicting relationships for all non-connected node pairs based on a previously trained LinkPrediction model',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.beta.pipeline.linkPrediction.train': {
      label: 'gds.beta.pipeline.linkPrediction.train',
      documentation: 'Trains a link prediction model based on a pipeline',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.beta.pipeline.linkPrediction.train.estimate': {
      label: 'gds.beta.pipeline.linkPrediction.train.estimate',
      documentation: 'Estimates memory for applying a linkPrediction model',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.beta.pipeline.nodeClassification.addLogisticRegression': {
      label: 'gds.beta.pipeline.nodeClassification.addLogisticRegression',
      documentation:
        'Add a logistic regression configuration to the parameter space of the node classification train pipeline.',
      parameters: [
        {
          label: 'pipelineName',
          documentation: 'pipelineName :: STRING?',
        },
        {
          label: 'config',
          documentation: 'config = {} :: MAP?',
        },
      ],
    },
    'gds.beta.pipeline.nodeClassification.addNodeProperty': {
      label: 'gds.beta.pipeline.nodeClassification.addNodeProperty',
      documentation:
        'Add a node property step to an existing node classification training pipeline.',
      parameters: [
        {
          label: 'pipelineName',
          documentation: 'pipelineName :: STRING?',
        },
        {
          label: 'procedureName',
          documentation: 'procedureName :: STRING?',
        },
        {
          label: 'procedureConfiguration',
          documentation: 'procedureConfiguration :: MAP?',
        },
      ],
    },
    'gds.beta.pipeline.nodeClassification.addRandomForest': {
      label: 'gds.beta.pipeline.nodeClassification.addRandomForest',
      documentation:
        'Add a random forest configuration to the parameter space of the node classification train pipeline.',
      parameters: [
        {
          label: 'pipelineName',
          documentation: 'pipelineName :: STRING?',
        },
        {
          label: 'config',
          documentation: 'config :: MAP?',
        },
      ],
    },
    'gds.beta.pipeline.nodeClassification.configureSplit': {
      label: 'gds.beta.pipeline.nodeClassification.configureSplit',
      documentation:
        'Configures the split of the node classification training pipeline.',
      parameters: [
        {
          label: 'pipelineName',
          documentation: 'pipelineName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration :: MAP?',
        },
      ],
    },
    'gds.beta.pipeline.nodeClassification.create': {
      label: 'gds.beta.pipeline.nodeClassification.create',
      documentation:
        'Creates a node classification training pipeline in the pipeline catalog.',
      parameters: [
        {
          label: 'pipelineName',
          documentation: 'pipelineName :: STRING?',
        },
      ],
    },
    'gds.beta.pipeline.nodeClassification.predict.mutate': {
      label: 'gds.beta.pipeline.nodeClassification.predict.mutate',
      documentation:
        'Predicts classes for all nodes based on a previously trained pipeline model',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.beta.pipeline.nodeClassification.predict.mutate.estimate': {
      label: 'gds.beta.pipeline.nodeClassification.predict.mutate.estimate',
      documentation:
        'Estimates memory for predicting classes for all nodes based on a previously trained pipeline model',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: ANY?',
        },
        {
          label: 'configuration',
          documentation: 'configuration :: MAP?',
        },
      ],
    },
    'gds.beta.pipeline.nodeClassification.predict.stream': {
      label: 'gds.beta.pipeline.nodeClassification.predict.stream',
      documentation:
        'Predicts classes for all nodes based on a previously trained pipeline model',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.beta.pipeline.nodeClassification.predict.stream.estimate': {
      label: 'gds.beta.pipeline.nodeClassification.predict.stream.estimate',
      documentation:
        'Estimates memory for predicting classes for all nodes based on a previously trained pipeline model',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: ANY?',
        },
        {
          label: 'configuration',
          documentation: 'configuration :: MAP?',
        },
      ],
    },
    'gds.beta.pipeline.nodeClassification.predict.write': {
      label: 'gds.beta.pipeline.nodeClassification.predict.write',
      documentation:
        'Predicts classes for all nodes based on a previously trained pipeline model',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.beta.pipeline.nodeClassification.predict.write.estimate': {
      label: 'gds.beta.pipeline.nodeClassification.predict.write.estimate',
      documentation:
        'Estimates memory for predicting classes for all nodes based on a previously trained pipeline model',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.beta.pipeline.nodeClassification.selectFeatures': {
      label: 'gds.beta.pipeline.nodeClassification.selectFeatures',
      documentation:
        'Add one or several features to an existing node classification training pipeline.',
      parameters: [
        {
          label: 'pipelineName',
          documentation: 'pipelineName :: STRING?',
        },
        {
          label: 'nodeProperties',
          documentation: 'nodeProperties :: ANY?',
        },
      ],
    },
    'gds.beta.pipeline.nodeClassification.train': {
      label: 'gds.beta.pipeline.nodeClassification.train',
      documentation: 'Trains a node classification model based on a pipeline',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.beta.pipeline.nodeClassification.train.estimate': {
      label: 'gds.beta.pipeline.nodeClassification.train.estimate',
      documentation:
        'Estimates memory for training a node classification model based on a pipeline',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.betweenness.mutate': {
      label: 'gds.betweenness.mutate',
      documentation:
        'Betweenness centrality measures the relative information flow that passes through a node.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.betweenness.mutate.estimate': {
      label: 'gds.betweenness.mutate.estimate',
      documentation:
        'Betweenness centrality measures the relative information flow that passes through a node.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.betweenness.stats': {
      label: 'gds.betweenness.stats',
      documentation:
        'Betweenness centrality measures the relative information flow that passes through a node.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.betweenness.stats.estimate': {
      label: 'gds.betweenness.stats.estimate',
      documentation:
        'Betweenness centrality measures the relative information flow that passes through a node.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.betweenness.stream': {
      label: 'gds.betweenness.stream',
      documentation:
        'Betweenness centrality measures the relative information flow that passes through a node.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.betweenness.stream.estimate': {
      label: 'gds.betweenness.stream.estimate',
      documentation:
        'Betweenness centrality measures the relative information flow that passes through a node.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.betweenness.write': {
      label: 'gds.betweenness.write',
      documentation:
        'Betweenness centrality measures the relative information flow that passes through a node.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.betweenness.write.estimate': {
      label: 'gds.betweenness.write.estimate',
      documentation:
        'Betweenness centrality measures the relative information flow that passes through a node.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.bfs.mutate': {
      label: 'gds.bfs.mutate',
      documentation:
        'BFS is a traversal algorithm, which explores all of the neighbor nodes at the present depth prior to moving on to the nodes at the next depth level.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.bfs.mutate.estimate': {
      label: 'gds.bfs.mutate.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.bfs.stats': {
      label: 'gds.bfs.stats',
      documentation:
        'BFS is a traversal algorithm, which explores all of the neighbor nodes at the present depth prior to moving on to the nodes at the next depth level.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.bfs.stats.estimate': {
      label: 'gds.bfs.stats.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.bfs.stream': {
      label: 'gds.bfs.stream',
      documentation:
        'BFS is a traversal algorithm, which explores all of the neighbor nodes at the present depth prior to moving on to the nodes at the next depth level.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.bfs.stream.estimate': {
      label: 'gds.bfs.stream.estimate',
      documentation:
        'BFS is a traversal algorithm, which explores all of the neighbor nodes at the present depth prior to moving on to the nodes at the next depth level.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: ANY?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.closeness.harmonic.mutate': {
      label: 'gds.closeness.harmonic.mutate',
      documentation:
        'Harmonic centrality is a way of detecting nodes that are able to spread information very efficiently through a graph.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.closeness.harmonic.stats': {
      label: 'gds.closeness.harmonic.stats',
      documentation:
        'Harmonic centrality is a way of detecting nodes that are able to spread information very efficiently through a graph.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.closeness.harmonic.stream': {
      label: 'gds.closeness.harmonic.stream',
      documentation:
        'Harmonic centrality is a way of detecting nodes that are able to spread information very efficiently through a graph.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.closeness.harmonic.write': {
      label: 'gds.closeness.harmonic.write',
      documentation:
        'Harmonic centrality is a way of detecting nodes that are able to spread information very efficiently through a graph.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.closeness.mutate': {
      label: 'gds.closeness.mutate',
      documentation:
        'Closeness centrality is a way of detecting nodes that are able to spread information very efficiently through a graph.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.closeness.stats': {
      label: 'gds.closeness.stats',
      documentation:
        'Closeness centrality is a way of detecting nodes that are able to spread information very efficiently through a graph.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.closeness.stream': {
      label: 'gds.closeness.stream',
      documentation:
        'Closeness centrality is a way of detecting nodes that are able to spread information very efficiently through a graph.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.closeness.write': {
      label: 'gds.closeness.write',
      documentation:
        'Closeness centrality is a way of detecting nodes that are able to spread information very efficiently through a graph.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.collapsePath.mutate': {
      label: 'gds.collapsePath.mutate',
      documentation:
        'Collapse Path algorithm is a traversal algorithm capable of creating relationships between the start and end nodes of a traversal',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.conductance.stream': {
      label: 'gds.conductance.stream',
      documentation:
        'Evaluates a division of nodes into communities based on the proportion of relationships that cross community boundaries.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.config.defaults.list': {
      label: 'gds.config.defaults.list',
      documentation:
        'List defaults; global by default, but also optionally for a specific user and/ or key',
      parameters: [
        {
          label: 'parameters',
          documentation: 'parameters = {} :: MAP?',
        },
      ],
    },
    'gds.config.defaults.set': {
      label: 'gds.config.defaults.set',
      documentation:
        'Set a default; global by, default, but also optionally for a specific user',
      parameters: [
        {
          label: 'key',
          documentation: 'key :: STRING?',
        },
        {
          label: 'value',
          documentation: 'value :: ANY?',
        },
        {
          label: 'username',
          documentation:
            'username = d81eb72e-c499-4f78-90c7-0c76123606a2 :: STRING?',
        },
      ],
    },
    'gds.config.limits.list': {
      label: 'gds.config.limits.list',
      documentation:
        'List limits; global by default, but also optionally for a specific user and/ or key',
      parameters: [
        {
          label: 'parameters',
          documentation: 'parameters = {} :: MAP?',
        },
      ],
    },
    'gds.config.limits.set': {
      label: 'gds.config.limits.set',
      documentation:
        'Set a limit; global by, default, but also optionally for a specific user',
      parameters: [
        {
          label: 'key',
          documentation: 'key :: STRING?',
        },
        {
          label: 'value',
          documentation: 'value :: ANY?',
        },
        {
          label: 'username',
          documentation:
            'username = d81eb72e-c499-4f78-90c7-0c76123606a2 :: STRING?',
        },
      ],
    },
    'gds.dag.longestPath.stream': {
      label: 'gds.dag.longestPath.stream',
      documentation: 'Returns the longest paths ending in given target nodes',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.dag.topologicalSort.stream': {
      label: 'gds.dag.topologicalSort.stream',
      documentation:
        'Returns all the nodes in the graph that are not part of a cycle or depend on a cycle, sorted in a topological order',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.debug.arrow': {
      label: 'gds.debug.arrow',
      documentation:
        'Returns details about the status of the GDS Flight server',
      parameters: [],
    },
    'gds.debug.sysInfo': {
      label: 'gds.debug.sysInfo',
      documentation: 'Returns details about the status of the system',
      parameters: [],
    },
    'gds.degree.mutate': {
      label: 'gds.degree.mutate',
      documentation:
        'Degree centrality measures the number of incoming and outgoing relationships from a node.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.degree.mutate.estimate': {
      label: 'gds.degree.mutate.estimate',
      documentation:
        'Degree centrality measures the number of incoming and outgoing relationships from a node.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.degree.stats': {
      label: 'gds.degree.stats',
      documentation:
        'Degree centrality measures the number of incoming and outgoing relationships from a node.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.degree.stats.estimate': {
      label: 'gds.degree.stats.estimate',
      documentation:
        'Degree centrality measures the number of incoming and outgoing relationships from a node.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.degree.stream': {
      label: 'gds.degree.stream',
      documentation:
        'Degree centrality measures the number of incoming and outgoing relationships from a node.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.degree.stream.estimate': {
      label: 'gds.degree.stream.estimate',
      documentation:
        'Degree centrality measures the number of incoming and outgoing relationships from a node.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.degree.write': {
      label: 'gds.degree.write',
      documentation:
        'Degree centrality measures the number of incoming and outgoing relationships from a node.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.degree.write.estimate': {
      label: 'gds.degree.write.estimate',
      documentation:
        'Degree centrality measures the number of incoming and outgoing relationships from a node.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.dfs.mutate': {
      label: 'gds.dfs.mutate',
      documentation:
        'Depth-first search (DFS) is an algorithm for traversing or searching tree or graph data structures. The algorithm starts at the root node (selecting some arbitrary node as the root node in the case of a graph) and explores as far as possible along each branch before backtracking.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.dfs.mutate.estimate': {
      label: 'gds.dfs.mutate.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.dfs.stream': {
      label: 'gds.dfs.stream',
      documentation:
        'Depth-first search (DFS) is an algorithm for traversing or searching tree or graph data structures. The algorithm starts at the root node (selecting some arbitrary node as the root node in the case of a graph) and explores as far as possible along each branch before backtracking.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.dfs.stream.estimate': {
      label: 'gds.dfs.stream.estimate',
      documentation:
        'Depth-first search (DFS) is an algorithm for traversing or searching tree or graph data structures. The algorithm starts at the root node (selecting some arbitrary node as the root node in the case of a graph) and explores as far as possible along each branch before backtracking.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: ANY?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.eigenvector.mutate': {
      label: 'gds.eigenvector.mutate',
      documentation:
        'Eigenvector Centrality is an algorithm that measures the transitive influence or connectivity of nodes.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.eigenvector.mutate.estimate': {
      label: 'gds.eigenvector.mutate.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.eigenvector.stats': {
      label: 'gds.eigenvector.stats',
      documentation:
        'Eigenvector Centrality is an algorithm that measures the transitive influence or connectivity of nodes.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.eigenvector.stats.estimate': {
      label: 'gds.eigenvector.stats.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.eigenvector.stream': {
      label: 'gds.eigenvector.stream',
      documentation:
        'Eigenvector Centrality is an algorithm that measures the transitive influence or connectivity of nodes.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.eigenvector.stream.estimate': {
      label: 'gds.eigenvector.stream.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.eigenvector.write': {
      label: 'gds.eigenvector.write',
      documentation:
        'Eigenvector Centrality is an algorithm that measures the transitive influence or connectivity of nodes.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.eigenvector.write.estimate': {
      label: 'gds.eigenvector.write.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.ephemeral.database.create': {
      label: 'gds.ephemeral.database.create',
      documentation: 'Creates an ephemeral database from a GDS graph.',
      parameters: [
        {
          label: 'dbName',
          documentation: 'dbName :: STRING?',
        },
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
      ],
    },
    'gds.ephemeral.database.drop': {
      label: 'gds.ephemeral.database.drop',
      documentation: 'Drop an ephemeral database backed by an in-memory graph',
      parameters: [
        {
          label: 'dbName',
          documentation: 'dbName :: STRING?',
        },
      ],
    },
    'gds.fastRP.mutate': {
      label: 'gds.fastRP.mutate',
      documentation:
        'Random Projection produces node embeddings via the fastrp algorithm',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.fastRP.mutate.estimate': {
      label: 'gds.fastRP.mutate.estimate',
      documentation:
        'Random Projection produces node embeddings via the fastrp algorithm',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.fastRP.stats': {
      label: 'gds.fastRP.stats',
      documentation:
        'Random Projection produces node embeddings via the fastrp algorithm',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.fastRP.stats.estimate': {
      label: 'gds.fastRP.stats.estimate',
      documentation:
        'Random Projection produces node embeddings via the fastrp algorithm',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.fastRP.stream': {
      label: 'gds.fastRP.stream',
      documentation:
        'Random Projection produces node embeddings via the fastrp algorithm',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.fastRP.stream.estimate': {
      label: 'gds.fastRP.stream.estimate',
      documentation:
        'Random Projection produces node embeddings via the fastrp algorithm',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.fastRP.write': {
      label: 'gds.fastRP.write',
      documentation:
        'Random Projection produces node embeddings via the fastrp algorithm',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.fastRP.write.estimate': {
      label: 'gds.fastRP.write.estimate',
      documentation:
        'Random Projection produces node embeddings via the fastrp algorithm',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.graph.drop': {
      label: 'gds.graph.drop',
      documentation:
        'Drops a named graph from the catalog and frees up the resources it occupies.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: ANY?',
        },
        {
          label: 'failIfMissing',
          documentation: 'failIfMissing = true :: BOOLEAN?',
        },
        {
          label: 'dbName',
          documentation: 'dbName =  :: STRING?',
        },
        {
          label: 'username',
          documentation: 'username =  :: STRING?',
        },
      ],
    },
    'gds.graph.exists': {
      label: 'gds.graph.exists',
      documentation: 'Checks if a graph exists in the catalog.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
      ],
    },
    'gds.graph.export': {
      label: 'gds.graph.export',
      documentation: 'Exports a named graph into a new offline Neo4j database.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.graph.export.csv': {
      label: 'gds.graph.export.csv',
      documentation: 'Exports a named graph to CSV files.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.graph.export.csv.estimate': {
      label: 'gds.graph.export.csv.estimate',
      documentation:
        'Estimate the required disk space for exporting a named graph to CSV files.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.graph.filter': {
      label: 'gds.graph.filter',
      documentation:
        'Applies node and relationship predicates on a graph and stores the result as a new graph in the catalog.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'fromGraphName',
          documentation: 'fromGraphName :: STRING?',
        },
        {
          label: 'nodeFilter',
          documentation: 'nodeFilter :: STRING?',
        },
        {
          label: 'relationshipFilter',
          documentation: 'relationshipFilter :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.graph.generate': {
      label: 'gds.graph.generate',
      documentation:
        'Computes a random graph, which will be stored in the graph catalog.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'nodeCount',
          documentation: 'nodeCount :: INTEGER?',
        },
        {
          label: 'averageDegree',
          documentation: 'averageDegree :: INTEGER?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.graph.graphProperty.drop': {
      label: 'gds.graph.graphProperty.drop',
      documentation: 'Removes a graph property from a projected graph.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'graphProperty',
          documentation: 'graphProperty :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.graph.graphProperty.stream': {
      label: 'gds.graph.graphProperty.stream',
      documentation: 'Streams the given graph property.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'graphProperty',
          documentation: 'graphProperty :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.graph.list': {
      label: 'gds.graph.list',
      documentation:
        'Lists information about named graphs stored in the catalog.',
      parameters: [
        {
          label: 'graphName',
          documentation:
            'graphName = d9b6394a-9482-4929-adab-f97df578a6c6 :: STRING?',
        },
      ],
    },
    'gds.graph.nodeLabel.mutate': {
      label: 'gds.graph.nodeLabel.mutate',
      documentation: 'Mutates the in-memory graph with the given node Label.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'nodeLabel',
          documentation: 'nodeLabel :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration :: MAP?',
        },
      ],
    },
    'gds.graph.nodeLabel.write': {
      label: 'gds.graph.nodeLabel.write',
      documentation: 'Writes the given node Label to an online Neo4j database.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'nodeLabel',
          documentation: 'nodeLabel :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration :: MAP?',
        },
      ],
    },
    'gds.graph.nodeProperties.drop': {
      label: 'gds.graph.nodeProperties.drop',
      documentation: 'Removes node properties from a projected graph.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'nodeProperties',
          documentation: 'nodeProperties :: ANY?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.graph.nodeProperties.stream': {
      label: 'gds.graph.nodeProperties.stream',
      documentation: 'Streams the given node properties.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'nodeProperties',
          documentation: 'nodeProperties :: ANY?',
        },
        {
          label: 'nodeLabels',
          documentation: 'nodeLabels = [*] :: ANY?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.graph.nodeProperties.write': {
      label: 'gds.graph.nodeProperties.write',
      documentation:
        'Writes the given node properties to an online Neo4j database.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'nodeProperties',
          documentation: 'nodeProperties :: ANY?',
        },
        {
          label: 'nodeLabels',
          documentation: 'nodeLabels = [*] :: ANY?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.graph.nodeProperty.stream': {
      label: 'gds.graph.nodeProperty.stream',
      documentation: 'Streams the given node property.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'nodeProperties',
          documentation: 'nodeProperties :: STRING?',
        },
        {
          label: 'nodeLabels',
          documentation: 'nodeLabels = [*] :: ANY?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.graph.project': {
      label: 'gds.graph.project',
      documentation:
        'Creates a named graph in the catalog for use by algorithms.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'nodeProjection',
          documentation: 'nodeProjection :: ANY?',
        },
        {
          label: 'relationshipProjection',
          documentation: 'relationshipProjection :: ANY?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.graph.project.cypher': {
      label: 'gds.graph.project.cypher',
      documentation:
        'Creates a named graph in the catalog for use by algorithms.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'nodeQuery',
          documentation: 'nodeQuery :: STRING?',
        },
        {
          label: 'relationshipQuery',
          documentation: 'relationshipQuery :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.graph.project.cypher.estimate': {
      label: 'gds.graph.project.cypher.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'nodeQuery',
          documentation: 'nodeQuery :: STRING?',
        },
        {
          label: 'relationshipQuery',
          documentation: 'relationshipQuery :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.graph.project.estimate': {
      label: 'gds.graph.project.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'nodeProjection',
          documentation: 'nodeProjection :: ANY?',
        },
        {
          label: 'relationshipProjection',
          documentation: 'relationshipProjection :: ANY?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.graph.relationship.write': {
      label: 'gds.graph.relationship.write',
      documentation:
        'Writes the given relationship and an optional relationship property to an online Neo4j database.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'relationshipType',
          documentation: 'relationshipType :: STRING?',
        },
        {
          label: 'relationshipProperty',
          documentation: 'relationshipProperty =  :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.graph.relationshipProperties.stream': {
      label: 'gds.graph.relationshipProperties.stream',
      documentation: 'Streams the given relationship properties.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'relationshipProperties',
          documentation: 'relationshipProperties :: LIST? OF STRING?',
        },
        {
          label: 'relationshipTypes',
          documentation: 'relationshipTypes = [*] :: LIST? OF STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.graph.relationshipProperties.write': {
      label: 'gds.graph.relationshipProperties.write',
      documentation:
        'Writes the given relationship and a list of relationship properties to an online Neo4j database.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'relationshipType',
          documentation: 'relationshipType :: STRING?',
        },
        {
          label: 'relationshipProperties',
          documentation: 'relationshipProperties :: LIST? OF STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration :: MAP?',
        },
      ],
    },
    'gds.graph.relationshipProperty.stream': {
      label: 'gds.graph.relationshipProperty.stream',
      documentation: 'Streams the given relationship property.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'relationshipProperty',
          documentation: 'relationshipProperty :: STRING?',
        },
        {
          label: 'relationshipTypes',
          documentation: 'relationshipTypes = [*] :: LIST? OF STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.graph.relationships.drop': {
      label: 'gds.graph.relationships.drop',
      documentation:
        'Delete the relationship type for a given graph stored in the graph-catalog.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'relationshipType',
          documentation: 'relationshipType :: STRING?',
        },
      ],
    },
    'gds.graph.relationships.stream': {
      label: 'gds.graph.relationships.stream',
      documentation: 'Streams the given relationship source/target pairs',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'relationshipTypes',
          documentation: 'relationshipTypes = [*] :: LIST? OF STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.graph.relationships.toUndirected': {
      label: 'gds.graph.relationships.toUndirected',
      documentation:
        'The ToUndirected procedure converts directed relationships to undirected relationships',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.graph.relationships.toUndirected.estimate': {
      label: 'gds.graph.relationships.toUndirected.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.graph.sample.cnarw': {
      label: 'gds.graph.sample.cnarw',
      documentation:
        'Constructs a random subgraph based on common neighbour aware random walks',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'fromGraphName',
          documentation: 'fromGraphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.graph.sample.cnarw.estimate': {
      label: 'gds.graph.sample.cnarw.estimate',
      documentation:
        'Estimate memory requirements for sampling graph using CNARW algorithm',
      parameters: [
        {
          label: 'fromGraphName',
          documentation: 'fromGraphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.graph.sample.rwr': {
      label: 'gds.graph.sample.rwr',
      documentation:
        'Constructs a random subgraph based on random walks with restarts',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'fromGraphName',
          documentation: 'fromGraphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.hashgnn.mutate': {
      label: 'gds.hashgnn.mutate',
      documentation:
        'HashGNN creates node embeddings by hashing and message passing.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.hashgnn.mutate.estimate': {
      label: 'gds.hashgnn.mutate.estimate',
      documentation:
        'HashGNN creates node embeddings by hashing and message passing.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.hashgnn.stream': {
      label: 'gds.hashgnn.stream',
      documentation:
        'HashGNN creates node embeddings by hashing and message passing.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.hashgnn.stream.estimate': {
      label: 'gds.hashgnn.stream.estimate',
      documentation:
        'HashGNN creates node embeddings by hashing and message passing.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.hits.mutate': {
      label: 'gds.hits.mutate',
      documentation:
        'Hyperlink-Induced Topic Search (HITS) is a link analysis algorithm that rates nodes',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.hits.mutate.estimate': {
      label: 'gds.hits.mutate.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.hits.stats': {
      label: 'gds.hits.stats',
      documentation:
        'Hyperlink-Induced Topic Search (HITS) is a link analysis algorithm that rates nodes',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.hits.stats.estimate': {
      label: 'gds.hits.stats.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.hits.stream': {
      label: 'gds.hits.stream',
      documentation:
        'Hyperlink-Induced Topic Search (HITS) is a link analysis algorithm that rates nodes',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.hits.stream.estimate': {
      label: 'gds.hits.stream.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.hits.write': {
      label: 'gds.hits.write',
      documentation:
        'Hyperlink-Induced Topic Search (HITS) is a link analysis algorithm that rates nodes',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.hits.write.estimate': {
      label: 'gds.hits.write.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.influenceMaximization.celf.mutate': {
      label: 'gds.influenceMaximization.celf.mutate',
      documentation:
        'The Cost Effective Lazy Forward (CELF) algorithm aims to find k nodes that maximize the expected spread of influence in the network.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.influenceMaximization.celf.mutate.estimate': {
      label: 'gds.influenceMaximization.celf.mutate.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.influenceMaximization.celf.stats': {
      label: 'gds.influenceMaximization.celf.stats',
      documentation:
        'Executes the algorithm and returns result statistics without writing the result to Neo4j.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.influenceMaximization.celf.stats.estimate': {
      label: 'gds.influenceMaximization.celf.stats.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.influenceMaximization.celf.stream': {
      label: 'gds.influenceMaximization.celf.stream',
      documentation:
        'The Cost Effective Lazy Forward (CELF) algorithm aims to find k nodes that maximize the expected spread of influence in the network.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.influenceMaximization.celf.stream.estimate': {
      label: 'gds.influenceMaximization.celf.stream.estimate',
      documentation:
        'The Cost Effective Lazy Forward (CELF) algorithm aims to find k nodes that maximize the expected spread of influence in the network.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: ANY?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.influenceMaximization.celf.write': {
      label: 'gds.influenceMaximization.celf.write',
      documentation:
        'The Cost Effective Lazy Forward (CELF) algorithm aims to find k nodes that maximize the expected spread of influence in the network.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.influenceMaximization.celf.write.estimate': {
      label: 'gds.influenceMaximization.celf.write.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.k1coloring.mutate': {
      label: 'gds.k1coloring.mutate',
      documentation:
        'The K-1 Coloring algorithm assigns a color to every node in the graph.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.k1coloring.mutate.estimate': {
      label: 'gds.k1coloring.mutate.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.k1coloring.stats': {
      label: 'gds.k1coloring.stats',
      documentation:
        'The K-1 Coloring algorithm assigns a color to every node in the graph.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.k1coloring.stats.estimate': {
      label: 'gds.k1coloring.stats.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.k1coloring.stream': {
      label: 'gds.k1coloring.stream',
      documentation:
        'The K-1 Coloring algorithm assigns a color to every node in the graph.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.k1coloring.stream.estimate': {
      label: 'gds.k1coloring.stream.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.k1coloring.write': {
      label: 'gds.k1coloring.write',
      documentation:
        'The K-1 Coloring algorithm assigns a color to every node in the graph.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.k1coloring.write.estimate': {
      label: 'gds.k1coloring.write.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.kSpanningTree.write': {
      label: 'gds.kSpanningTree.write',
      documentation:
        'The K-spanning tree algorithm starts from a root node and returns a spanning tree with exactly k nodes',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.kcore.mutate': {
      label: 'gds.kcore.mutate',
      documentation: 'It computes the k-core values in a network',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.kcore.mutate.estimate': {
      label: 'gds.kcore.mutate.estimate',
      documentation: 'It computes the k-core values in a network',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.kcore.stats': {
      label: 'gds.kcore.stats',
      documentation: 'It computes the k-core values in a network',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.kcore.stats.estimate': {
      label: 'gds.kcore.stats.estimate',
      documentation: 'It computes the k-core values in a network',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.kcore.stream': {
      label: 'gds.kcore.stream',
      documentation: 'It computes the k-core values in a network',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.kcore.stream.estimate': {
      label: 'gds.kcore.stream.estimate',
      documentation: 'It computes the k-core values in a network',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.kcore.write': {
      label: 'gds.kcore.write',
      documentation: 'It computes the k-core values in a network',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.kcore.write.estimate': {
      label: 'gds.kcore.write.estimate',
      documentation: 'It computes the k-core values in a network',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.kmeans.mutate': {
      label: 'gds.kmeans.mutate',
      documentation:
        'The Kmeans  algorithm clusters nodes into different communities based on Euclidean distance',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.kmeans.mutate.estimate': {
      label: 'gds.kmeans.mutate.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.kmeans.stats': {
      label: 'gds.kmeans.stats',
      documentation:
        'The Kmeans  algorithm clusters nodes into different communities based on Euclidean distance',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.kmeans.stats.estimate': {
      label: 'gds.kmeans.stats.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.kmeans.stream': {
      label: 'gds.kmeans.stream',
      documentation:
        'The Kmeans  algorithm clusters nodes into different communities based on Euclidean distance',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.kmeans.stream.estimate': {
      label: 'gds.kmeans.stream.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.kmeans.write': {
      label: 'gds.kmeans.write',
      documentation:
        'The Kmeans  algorithm clusters nodes into different communities based on Euclidean distance',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.kmeans.write.estimate': {
      label: 'gds.kmeans.write.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.knn.filtered.mutate': {
      label: 'gds.knn.filtered.mutate',
      documentation:
        'The k-nearest neighbor graph algorithm constructs relationships between nodes if the distance between two nodes is among the k nearest distances compared to other nodes. KNN computes distances based on the similarity of node properties. Filtered KNN extends this functionality, allowing filtering on source nodes and target nodes, respectively.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.knn.filtered.mutate.estimate': {
      label: 'gds.knn.filtered.mutate.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.knn.filtered.stats': {
      label: 'gds.knn.filtered.stats',
      documentation:
        'The k-nearest neighbor graph algorithm constructs relationships between nodes if the distance between two nodes is among the k nearest distances compared to other nodes. KNN computes distances based on the similarity of node properties. Filtered KNN extends this functionality, allowing filtering on source nodes and target nodes, respectively.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.knn.filtered.stats.estimate': {
      label: 'gds.knn.filtered.stats.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.knn.filtered.stream': {
      label: 'gds.knn.filtered.stream',
      documentation:
        'The k-nearest neighbor graph algorithm constructs relationships between nodes if the distance between two nodes is among the k nearest distances compared to other nodes. KNN computes distances based on the similarity of node properties. Filtered KNN extends this functionality, allowing filtering on source nodes and target nodes, respectively.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.knn.filtered.stream.estimate': {
      label: 'gds.knn.filtered.stream.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.knn.filtered.write': {
      label: 'gds.knn.filtered.write',
      documentation:
        'The k-nearest neighbor graph algorithm constructs relationships between nodes if the distance between two nodes is among the k nearest distances compared to other nodes. KNN computes distances based on the similarity of node properties. Filtered KNN extends this functionality, allowing filtering on source nodes and target nodes, respectively.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.knn.filtered.write.estimate': {
      label: 'gds.knn.filtered.write.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.knn.mutate': {
      label: 'gds.knn.mutate',
      documentation:
        'The k-nearest neighbor graph algorithm constructs relationships between nodes if the distance between two nodes is among the k nearest distances compared to other nodes.KNN computes distances based on the similarity of node properties',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.knn.mutate.estimate': {
      label: 'gds.knn.mutate.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.knn.stats': {
      label: 'gds.knn.stats',
      documentation:
        'The k-nearest neighbor graph algorithm constructs relationships between nodes if the distance between two nodes is among the k nearest distances compared to other nodes.KNN computes distances based on the similarity of node properties',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.knn.stats.estimate': {
      label: 'gds.knn.stats.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.knn.stream': {
      label: 'gds.knn.stream',
      documentation:
        'The k-nearest neighbor graph algorithm constructs relationships between nodes if the distance between two nodes is among the k nearest distances compared to other nodes.KNN computes distances based on the similarity of node properties',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.knn.stream.estimate': {
      label: 'gds.knn.stream.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.knn.write': {
      label: 'gds.knn.write',
      documentation:
        'The k-nearest neighbor graph algorithm constructs relationships between nodes if the distance between two nodes is among the k nearest distances compared to other nodes.KNN computes distances based on the similarity of node properties',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.knn.write.estimate': {
      label: 'gds.knn.write.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.labelPropagation.mutate': {
      label: 'gds.labelPropagation.mutate',
      documentation:
        'The Label Propagation algorithm is a fast algorithm for finding communities in a graph.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.labelPropagation.mutate.estimate': {
      label: 'gds.labelPropagation.mutate.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.labelPropagation.stats': {
      label: 'gds.labelPropagation.stats',
      documentation:
        'The Label Propagation algorithm is a fast algorithm for finding communities in a graph.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.labelPropagation.stats.estimate': {
      label: 'gds.labelPropagation.stats.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.labelPropagation.stream': {
      label: 'gds.labelPropagation.stream',
      documentation:
        'The Label Propagation algorithm is a fast algorithm for finding communities in a graph.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.labelPropagation.stream.estimate': {
      label: 'gds.labelPropagation.stream.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.labelPropagation.write': {
      label: 'gds.labelPropagation.write',
      documentation:
        'The Label Propagation algorithm is a fast algorithm for finding communities in a graph.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.labelPropagation.write.estimate': {
      label: 'gds.labelPropagation.write.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.leiden.mutate': {
      label: 'gds.leiden.mutate',
      documentation:
        'Leiden is a community detection algorithm, which guarantees that communities are well connected',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.leiden.mutate.estimate': {
      label: 'gds.leiden.mutate.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.leiden.stats': {
      label: 'gds.leiden.stats',
      documentation:
        'Executes the algorithm and returns result statistics without writing the result to Neo4j.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.leiden.stats.estimate': {
      label: 'gds.leiden.stats.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.leiden.stream': {
      label: 'gds.leiden.stream',
      documentation:
        'Leiden is a community detection algorithm, which guarantees that communities are well connected',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.leiden.stream.estimate': {
      label: 'gds.leiden.stream.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.leiden.write': {
      label: 'gds.leiden.write',
      documentation:
        'Leiden is a community detection algorithm, which guarantees that communities are well connected',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.leiden.write.estimate': {
      label: 'gds.leiden.write.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.license.state': {
      label: 'gds.license.state',
      documentation: 'Returns details about the license state',
      parameters: [],
    },
    'gds.list': {
      label: 'gds.list',
      documentation:
        'CALL gds.list - lists all algorithm procedures, their description and signature',
      parameters: [
        {
          label: 'name',
          documentation: 'name =  :: STRING?',
        },
      ],
    },
    'gds.listProgress': {
      label: 'gds.listProgress',
      documentation: 'List progress events for currently running tasks.',
      parameters: [
        {
          label: 'jobId',
          documentation: 'jobId =  :: STRING?',
        },
      ],
    },
    'gds.localClusteringCoefficient.mutate': {
      label: 'gds.localClusteringCoefficient.mutate',
      documentation:
        'The local clustering coefficient is a metric quantifying how connected the neighborhood of a node is.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.localClusteringCoefficient.mutate.estimate': {
      label: 'gds.localClusteringCoefficient.mutate.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.localClusteringCoefficient.stats': {
      label: 'gds.localClusteringCoefficient.stats',
      documentation:
        'Executes the algorithm and returns result statistics without writing the result to Neo4j.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.localClusteringCoefficient.stats.estimate': {
      label: 'gds.localClusteringCoefficient.stats.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.localClusteringCoefficient.stream': {
      label: 'gds.localClusteringCoefficient.stream',
      documentation:
        'The local clustering coefficient is a metric quantifying how connected the neighborhood of a node is.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.localClusteringCoefficient.stream.estimate': {
      label: 'gds.localClusteringCoefficient.stream.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.localClusteringCoefficient.write': {
      label: 'gds.localClusteringCoefficient.write',
      documentation:
        'The local clustering coefficient is a metric quantifying how connected the neighborhood of a node is.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.localClusteringCoefficient.write.estimate': {
      label: 'gds.localClusteringCoefficient.write.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.louvain.mutate': {
      label: 'gds.louvain.mutate',
      documentation:
        'The Louvain method for community detection is an algorithm for detecting communities in networks.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.louvain.mutate.estimate': {
      label: 'gds.louvain.mutate.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.louvain.stats': {
      label: 'gds.louvain.stats',
      documentation:
        'Executes the algorithm and returns result statistics without writing the result to Neo4j.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.louvain.stats.estimate': {
      label: 'gds.louvain.stats.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.louvain.stream': {
      label: 'gds.louvain.stream',
      documentation:
        'The Louvain method for community detection is an algorithm for detecting communities in networks.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.louvain.stream.estimate': {
      label: 'gds.louvain.stream.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.louvain.write': {
      label: 'gds.louvain.write',
      documentation:
        'The Louvain method for community detection is an algorithm for detecting communities in networks.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.louvain.write.estimate': {
      label: 'gds.louvain.write.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.maxkcut.mutate': {
      label: 'gds.maxkcut.mutate',
      documentation:
        'Approximate Maximum k-cut maps each node into one of k disjoint communities trying to maximize the sum of weights of relationships between these communities.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.maxkcut.mutate.estimate': {
      label: 'gds.maxkcut.mutate.estimate',
      documentation:
        'Approximate Maximum k-cut maps each node into one of k disjoint communities trying to maximize the sum of weights of relationships between these communities.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.maxkcut.stream': {
      label: 'gds.maxkcut.stream',
      documentation:
        'Approximate Maximum k-cut maps each node into one of k disjoint communities trying to maximize the sum of weights of relationships between these communities.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.maxkcut.stream.estimate': {
      label: 'gds.maxkcut.stream.estimate',
      documentation:
        'Approximate Maximum k-cut maps each node into one of k disjoint communities trying to maximize the sum of weights of relationships between these communities.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.model.delete': {
      label: 'gds.model.delete',
      documentation: 'Deletes a stored model from disk.',
      parameters: [
        {
          label: 'modelName',
          documentation: 'modelName :: STRING?',
        },
      ],
    },
    'gds.model.drop': {
      label: 'gds.model.drop',
      documentation:
        'Drops a loaded model and frees up the resources it occupies.',
      parameters: [
        {
          label: 'modelName',
          documentation: 'modelName :: STRING?',
        },
        {
          label: 'failIfMissing',
          documentation: 'failIfMissing = true :: BOOLEAN?',
        },
      ],
    },
    'gds.model.exists': {
      label: 'gds.model.exists',
      documentation: 'Checks if a given model exists in the model catalog.',
      parameters: [
        {
          label: 'modelName',
          documentation: 'modelName :: STRING?',
        },
      ],
    },
    'gds.model.list': {
      label: 'gds.model.list',
      documentation: 'Lists all models contained in the model catalog.',
      parameters: [
        {
          label: 'modelName',
          documentation: 'modelName = __NO_VALUE :: STRING?',
        },
      ],
    },
    'gds.model.load': {
      label: 'gds.model.load',
      documentation: 'Load a stored model into main memory.',
      parameters: [
        {
          label: 'modelName',
          documentation: 'modelName :: STRING?',
        },
      ],
    },
    'gds.model.publish': {
      label: 'gds.model.publish',
      documentation: 'Make a trained model accessible by all users',
      parameters: [
        {
          label: 'modelName',
          documentation: 'modelName :: STRING?',
        },
      ],
    },
    'gds.model.store': {
      label: 'gds.model.store',
      documentation: 'Store the selected model to disk.',
      parameters: [
        {
          label: 'modelName',
          documentation: 'modelName :: STRING?',
        },
        {
          label: 'failIfUnsupported',
          documentation: 'failIfUnsupported = true :: BOOLEAN?',
        },
      ],
    },
    'gds.modularity.stats': {
      label: 'gds.modularity.stats',
      documentation:
        'The Modularity procedure computes the modularity scores for a given set of communities/',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.modularity.stats.estimate': {
      label: 'gds.modularity.stats.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.modularity.stream': {
      label: 'gds.modularity.stream',
      documentation:
        'The Modularity procedure computes the modularity scores for a given set of communities/',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.modularity.stream.estimate': {
      label: 'gds.modularity.stream.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.modularityOptimization.mutate': {
      label: 'gds.modularityOptimization.mutate',
      documentation:
        'The Modularity Optimization algorithm groups the nodes in the graph by optimizing the graphs modularity.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.modularityOptimization.mutate.estimate': {
      label: 'gds.modularityOptimization.mutate.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.modularityOptimization.stats': {
      label: 'gds.modularityOptimization.stats',
      documentation:
        'The Modularity Optimization algorithm groups the nodes in the graph by optimizing the graphs modularity.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.modularityOptimization.stats.estimate': {
      label: 'gds.modularityOptimization.stats.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.modularityOptimization.stream': {
      label: 'gds.modularityOptimization.stream',
      documentation:
        'The Modularity Optimization algorithm groups the nodes in the graph by optimizing the graphs modularity.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.modularityOptimization.stream.estimate': {
      label: 'gds.modularityOptimization.stream.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.modularityOptimization.write': {
      label: 'gds.modularityOptimization.write',
      documentation:
        'The Modularity Optimization algorithm groups the nodes in the graph by optimizing the graphs modularity.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.modularityOptimization.write.estimate': {
      label: 'gds.modularityOptimization.write.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.node2vec.mutate': {
      label: 'gds.node2vec.mutate',
      documentation:
        'The Node2Vec algorithm computes embeddings for nodes based on random walks.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.node2vec.mutate.estimate': {
      label: 'gds.node2vec.mutate.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.node2vec.stream': {
      label: 'gds.node2vec.stream',
      documentation:
        'The Node2Vec algorithm computes embeddings for nodes based on random walks.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.node2vec.stream.estimate': {
      label: 'gds.node2vec.stream.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.node2vec.write': {
      label: 'gds.node2vec.write',
      documentation:
        'The Node2Vec algorithm computes embeddings for nodes based on random walks.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.node2vec.write.estimate': {
      label: 'gds.node2vec.write.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.nodeSimilarity.filtered.mutate': {
      label: 'gds.nodeSimilarity.filtered.mutate',
      documentation:
        'The Filtered Node Similarity algorithm compares a set of nodes based on the nodes they are connected to. Two nodes are considered similar if they share many of the same neighbors. The algorithm computes pair-wise similarities based on Jaccard or Overlap metrics. The filtered variant supports limiting which nodes to compare via source and target node filters.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.nodeSimilarity.filtered.mutate.estimate': {
      label: 'gds.nodeSimilarity.filtered.mutate.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.nodeSimilarity.filtered.stats': {
      label: 'gds.nodeSimilarity.filtered.stats',
      documentation:
        'The Filtered Node Similarity algorithm compares a set of nodes based on the nodes they are connected to. Two nodes are considered similar if they share many of the same neighbors. The algorithm computes pair-wise similarities based on Jaccard or Overlap metrics. The filtered variant supports limiting which nodes to compare via source and target node filters.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.nodeSimilarity.filtered.stats.estimate': {
      label: 'gds.nodeSimilarity.filtered.stats.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.nodeSimilarity.filtered.stream': {
      label: 'gds.nodeSimilarity.filtered.stream',
      documentation:
        'The Filtered Node Similarity algorithm compares a set of nodes based on the nodes they are connected to. Two nodes are considered similar if they share many of the same neighbors. The algorithm computes pair-wise similarities based on Jaccard or Overlap metrics. The filtered variant supports limiting which nodes to compare via source and target node filters.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.nodeSimilarity.filtered.stream.estimate': {
      label: 'gds.nodeSimilarity.filtered.stream.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.nodeSimilarity.filtered.write': {
      label: 'gds.nodeSimilarity.filtered.write',
      documentation:
        'The Filtered Node Similarity algorithm compares a set of nodes based on the nodes they are connected to. Two nodes are considered similar if they share many of the same neighbors. The algorithm computes pair-wise similarities based on Jaccard or Overlap metrics. The filtered variant supports limiting which nodes to compare via source and target node filters.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.nodeSimilarity.filtered.write.estimate': {
      label: 'gds.nodeSimilarity.filtered.write.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.nodeSimilarity.mutate': {
      label: 'gds.nodeSimilarity.mutate',
      documentation:
        'The Node Similarity algorithm compares a set of nodes based on the nodes they are connected to. Two nodes are considered similar if they share many of the same neighbors. Node Similarity computes pair-wise similarities based on the Jaccard metric.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.nodeSimilarity.mutate.estimate': {
      label: 'gds.nodeSimilarity.mutate.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.nodeSimilarity.stats': {
      label: 'gds.nodeSimilarity.stats',
      documentation:
        'The Node Similarity algorithm compares a set of nodes based on the nodes they are connected to. Two nodes are considered similar if they share many of the same neighbors. Node Similarity computes pair-wise similarities based on the Jaccard metric.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.nodeSimilarity.stats.estimate': {
      label: 'gds.nodeSimilarity.stats.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.nodeSimilarity.stream': {
      label: 'gds.nodeSimilarity.stream',
      documentation:
        'The Node Similarity algorithm compares a set of nodes based on the nodes they are connected to. Two nodes are considered similar if they share many of the same neighbors. Node Similarity computes pair-wise similarities based on the Jaccard metric.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.nodeSimilarity.stream.estimate': {
      label: 'gds.nodeSimilarity.stream.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.nodeSimilarity.write': {
      label: 'gds.nodeSimilarity.write',
      documentation:
        'The Node Similarity algorithm compares a set of nodes based on the nodes they are connected to. Two nodes are considered similar if they share many of the same neighbors. Node Similarity computes pair-wise similarities based on the Jaccard metric.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.nodeSimilarity.write.estimate': {
      label: 'gds.nodeSimilarity.write.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.pageRank.mutate': {
      label: 'gds.pageRank.mutate',
      documentation:
        'Page Rank is an algorithm that measures the transitive influence or connectivity of nodes.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.pageRank.mutate.estimate': {
      label: 'gds.pageRank.mutate.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.pageRank.stats': {
      label: 'gds.pageRank.stats',
      documentation:
        'Executes the algorithm and returns result statistics without writing the result to Neo4j.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.pageRank.stats.estimate': {
      label: 'gds.pageRank.stats.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.pageRank.stream': {
      label: 'gds.pageRank.stream',
      documentation:
        'Page Rank is an algorithm that measures the transitive influence or connectivity of nodes.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.pageRank.stream.estimate': {
      label: 'gds.pageRank.stream.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.pageRank.write': {
      label: 'gds.pageRank.write',
      documentation:
        'Page Rank is an algorithm that measures the transitive influence or connectivity of nodes.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.pageRank.write.estimate': {
      label: 'gds.pageRank.write.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.pipeline.drop': {
      label: 'gds.pipeline.drop',
      documentation: 'Drops a pipeline and frees up the resources it occupies.',
      parameters: [
        {
          label: 'pipelineName',
          documentation: 'pipelineName :: STRING?',
        },
        {
          label: 'failIfMissing',
          documentation: 'failIfMissing = true :: BOOLEAN?',
        },
      ],
    },
    'gds.pipeline.exists': {
      label: 'gds.pipeline.exists',
      documentation:
        'Checks if a given pipeline exists in the pipeline catalog.',
      parameters: [
        {
          label: 'pipelineName',
          documentation: 'pipelineName :: STRING?',
        },
      ],
    },
    'gds.pipeline.list': {
      label: 'gds.pipeline.list',
      documentation: 'Lists all pipelines contained in the pipeline catalog.',
      parameters: [
        {
          label: 'pipelineName',
          documentation: 'pipelineName = __NO_VALUE :: STRING?',
        },
      ],
    },
    'gds.randomWalk.stats': {
      label: 'gds.randomWalk.stats',
      documentation:
        'Random Walk is an algorithm that provides random paths in a graph. Its similar to how a drunk person traverses a city.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.randomWalk.stats.estimate': {
      label: 'gds.randomWalk.stats.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.randomWalk.stream': {
      label: 'gds.randomWalk.stream',
      documentation:
        'Random Walk is an algorithm that provides random paths in a graph. Its similar to how a drunk person traverses a city.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.randomWalk.stream.estimate': {
      label: 'gds.randomWalk.stream.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.restore': {
      label: 'gds.restore',
      documentation: 'The restore procedure reads graphs and models from disk.',
      parameters: [
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.scaleProperties.mutate': {
      label: 'gds.scaleProperties.mutate',
      documentation: 'Scale node properties',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.scaleProperties.mutate.estimate': {
      label: 'gds.scaleProperties.mutate.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.scaleProperties.stats': {
      label: 'gds.scaleProperties.stats',
      documentation: 'Scale node properties',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.scaleProperties.stats.estimate': {
      label: 'gds.scaleProperties.stats.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.scaleProperties.stream': {
      label: 'gds.scaleProperties.stream',
      documentation: 'Scale node properties',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.scaleProperties.stream.estimate': {
      label: 'gds.scaleProperties.stream.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.scaleProperties.write': {
      label: 'gds.scaleProperties.write',
      documentation: 'Scale node properties',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.scaleProperties.write.estimate': {
      label: 'gds.scaleProperties.write.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.scc.mutate': {
      label: 'gds.scc.mutate',
      documentation:
        'The SCC algorithm finds sets of connected nodes in an directed graph, where all nodes in the same set form a connected component.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.scc.mutate.estimate': {
      label: 'gds.scc.mutate.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.scc.stats': {
      label: 'gds.scc.stats',
      documentation:
        'The SCC algorithm finds sets of connected nodes in an directed graph, where all nodes in the same set form a connected component.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.scc.stats.estimate': {
      label: 'gds.scc.stats.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.scc.stream': {
      label: 'gds.scc.stream',
      documentation:
        'The SCC algorithm finds sets of connected nodes in an directed graph, where all nodes in the same set form a connected component.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.scc.stream.estimate': {
      label: 'gds.scc.stream.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.scc.write': {
      label: 'gds.scc.write',
      documentation:
        'The SCC algorithm finds sets of connected nodes in an directed graph, where all nodes in the same set form a connected component.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.scc.write.estimate': {
      label: 'gds.scc.write.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.shortestPath.astar.mutate': {
      label: 'gds.shortestPath.astar.mutate',
      documentation:
        'The A* shortest path algorithm computes the shortest path between a pair of nodes. It uses the relationship weight property to compare path lengths. In addition, this implementation uses the haversine distance as a heuristic to converge faster.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.shortestPath.astar.mutate.estimate': {
      label: 'gds.shortestPath.astar.mutate.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.shortestPath.astar.stream': {
      label: 'gds.shortestPath.astar.stream',
      documentation:
        'The A* shortest path algorithm computes the shortest path between a pair of nodes. It uses the relationship weight property to compare path lengths. In addition, this implementation uses the haversine distance as a heuristic to converge faster.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.shortestPath.astar.stream.estimate': {
      label: 'gds.shortestPath.astar.stream.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.shortestPath.astar.write': {
      label: 'gds.shortestPath.astar.write',
      documentation:
        'The A* shortest path algorithm computes the shortest path between a pair of nodes. It uses the relationship weight property to compare path lengths. In addition, this implementation uses the haversine distance as a heuristic to converge faster.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.shortestPath.astar.write.estimate': {
      label: 'gds.shortestPath.astar.write.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.shortestPath.dijkstra.mutate': {
      label: 'gds.shortestPath.dijkstra.mutate',
      documentation:
        'The Dijkstra shortest path algorithm computes the shortest (weighted) path between a pair of nodes.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.shortestPath.dijkstra.mutate.estimate': {
      label: 'gds.shortestPath.dijkstra.mutate.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.shortestPath.dijkstra.stream': {
      label: 'gds.shortestPath.dijkstra.stream',
      documentation:
        'The Dijkstra shortest path algorithm computes the shortest (weighted) path between a pair of nodes.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.shortestPath.dijkstra.stream.estimate': {
      label: 'gds.shortestPath.dijkstra.stream.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.shortestPath.dijkstra.write': {
      label: 'gds.shortestPath.dijkstra.write',
      documentation:
        'The Dijkstra shortest path algorithm computes the shortest (weighted) path between a pair of nodes.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.shortestPath.dijkstra.write.estimate': {
      label: 'gds.shortestPath.dijkstra.write.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.shortestPath.yens.mutate': {
      label: 'gds.shortestPath.yens.mutate',
      documentation:
        "The Yen's shortest path algorithm computes the k shortest (weighted) paths between a pair of nodes.",
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.shortestPath.yens.mutate.estimate': {
      label: 'gds.shortestPath.yens.mutate.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.shortestPath.yens.stream': {
      label: 'gds.shortestPath.yens.stream',
      documentation:
        "The Yen's shortest path algorithm computes the k shortest (weighted) paths between a pair of nodes.",
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.shortestPath.yens.stream.estimate': {
      label: 'gds.shortestPath.yens.stream.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: ANY?',
        },
        {
          label: 'configuration',
          documentation: 'configuration :: MAP?',
        },
      ],
    },
    'gds.shortestPath.yens.write': {
      label: 'gds.shortestPath.yens.write',
      documentation:
        "The Yen's shortest path algorithm computes the k shortest (weighted) paths between a pair of nodes.",
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.shortestPath.yens.write.estimate': {
      label: 'gds.shortestPath.yens.write.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: ANY?',
        },
        {
          label: 'configuration',
          documentation: 'configuration :: MAP?',
        },
      ],
    },
    'gds.sllpa.mutate': {
      label: 'gds.sllpa.mutate',
      documentation:
        'The Speaker Listener Label Propagation algorithm is a fast algorithm for finding overlapping communities in a graph.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.sllpa.mutate.estimate': {
      label: 'gds.sllpa.mutate.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.sllpa.stats': {
      label: 'gds.sllpa.stats',
      documentation:
        'The Speaker Listener Label Propagation algorithm is a fast algorithm for finding overlapping communities in a graph.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.sllpa.stats.estimate': {
      label: 'gds.sllpa.stats.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.sllpa.stream': {
      label: 'gds.sllpa.stream',
      documentation:
        'The Speaker Listener Label Propagation algorithm is a fast algorithm for finding overlapping communities in a graph.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.sllpa.stream.estimate': {
      label: 'gds.sllpa.stream.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.sllpa.write': {
      label: 'gds.sllpa.write',
      documentation:
        'The Speaker Listener Label Propagation algorithm is a fast algorithm for finding overlapping communities in a graph.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.sllpa.write.estimate': {
      label: 'gds.sllpa.write.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.spanningTree.mutate': {
      label: 'gds.spanningTree.mutate',
      documentation:
        'The spanning tree algorithm visits all nodes that are in the same connected component as the starting node, and returns a spanning tree of all nodes in the component where the total weight of the relationships is either minimized or maximized.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.spanningTree.mutate.estimate': {
      label: 'gds.spanningTree.mutate.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.spanningTree.stats': {
      label: 'gds.spanningTree.stats',
      documentation:
        'The spanning tree algorithm visits all nodes that are in the same connected component as the starting node, and returns a spanning tree of all nodes in the component where the total weight of the relationships is either minimized or maximized.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.spanningTree.stats.estimate': {
      label: 'gds.spanningTree.stats.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.spanningTree.stream': {
      label: 'gds.spanningTree.stream',
      documentation:
        'The spanning tree algorithm visits all nodes that are in the same connected component as the starting node, and returns a spanning tree of all nodes in the component where the total weight of the relationships is either minimized or maximized.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.spanningTree.stream.estimate': {
      label: 'gds.spanningTree.stream.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.spanningTree.write': {
      label: 'gds.spanningTree.write',
      documentation:
        'The spanning tree algorithm visits all nodes that are in the same connected component as the starting node, and returns a spanning tree of all nodes in the component where the total weight of the relationships is either minimized or maximized.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.spanningTree.write.estimate': {
      label: 'gds.spanningTree.write.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.steinerTree.mutate': {
      label: 'gds.steinerTree.mutate',
      documentation:
        'The steiner tree algorithm accepts a source node, as well as a list of target nodes. It then attempts to find a spanning tree where there is a path from the source node to each target node, such that the total weight of the relationships is as low as possible.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.steinerTree.mutate.estimate': {
      label: 'gds.steinerTree.mutate.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: ANY?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.steinerTree.stats': {
      label: 'gds.steinerTree.stats',
      documentation:
        'The steiner tree algorithm accepts a source node, as well as a list of target nodes. It then attempts to find a spanning tree where there is a path from the source node to each target node, such that the total weight of the relationships is as low as possible.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.steinerTree.stats.estimate': {
      label: 'gds.steinerTree.stats.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: ANY?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.steinerTree.stream': {
      label: 'gds.steinerTree.stream',
      documentation:
        'The steiner tree algorithm accepts a source node, as well as a list of target nodes. It then attempts to find a spanning tree where there is a path from the source node to each target node, such that the total weight of the relationships is as low as possible.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.steinerTree.stream.estimate': {
      label: 'gds.steinerTree.stream.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: ANY?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.steinerTree.write': {
      label: 'gds.steinerTree.write',
      documentation:
        'The steiner tree algorithm accepts a source node, as well as a list of target nodes. It then attempts to find a spanning tree where there is a path from the source node to each target node, such that the total weight of the relationships is as low as possible.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.steinerTree.write.estimate': {
      label: 'gds.steinerTree.write.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: ANY?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.systemMonitor': {
      label: 'gds.systemMonitor',
      documentation:
        "Get an overview of the system's workload and available resources",
      parameters: [],
    },
    'gds.triangleCount.mutate': {
      label: 'gds.triangleCount.mutate',
      documentation:
        'Triangle counting is a community detection graph algorithm that is used to determine the number of triangles passing through each node in the graph.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.triangleCount.mutate.estimate': {
      label: 'gds.triangleCount.mutate.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.triangleCount.stats': {
      label: 'gds.triangleCount.stats',
      documentation:
        'Triangle counting is a community detection graph algorithm that is used to determine the number of triangles passing through each node in the graph.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.triangleCount.stats.estimate': {
      label: 'gds.triangleCount.stats.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.triangleCount.stream': {
      label: 'gds.triangleCount.stream',
      documentation:
        'Triangle counting is a community detection graph algorithm that is used to determine the number of triangles passing through each node in the graph.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.triangleCount.stream.estimate': {
      label: 'gds.triangleCount.stream.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.triangleCount.write': {
      label: 'gds.triangleCount.write',
      documentation:
        'Triangle counting is a community detection graph algorithm that is used to determine the number of triangles passing through each node in the graph.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.triangleCount.write.estimate': {
      label: 'gds.triangleCount.write.estimate',
      documentation:
        'Triangle counting is a community detection graph algorithm that is used to determine the number of triangles passing through each node in the graph.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.triangles': {
      label: 'gds.triangles',
      documentation:
        'Triangles streams the nodeIds of each triangle in the graph.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.userLog': {
      label: 'gds.userLog',
      documentation: 'Log warnings and hints for currently running tasks.',
      parameters: [
        {
          label: 'jobId',
          documentation: 'jobId =  :: STRING?',
        },
      ],
    },
    'gds.version': {
      label: 'gds.version',
      documentation:
        'CALL gds.version() | Return the installed graph data science library version.',
      parameters: [],
    },
    'gds.wcc.mutate': {
      label: 'gds.wcc.mutate',
      documentation:
        'The WCC algorithm finds sets of connected nodes in an undirected graph, where all nodes in the same set form a connected component.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.wcc.mutate.estimate': {
      label: 'gds.wcc.mutate.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.wcc.stats': {
      label: 'gds.wcc.stats',
      documentation:
        'The WCC algorithm finds sets of connected nodes in an undirected graph, where all nodes in the same set form a connected component.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.wcc.stats.estimate': {
      label: 'gds.wcc.stats.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.wcc.stream': {
      label: 'gds.wcc.stream',
      documentation:
        'The WCC algorithm finds sets of connected nodes in an undirected graph, where all nodes in the same set form a connected component.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.wcc.stream.estimate': {
      label: 'gds.wcc.stream.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'gds.wcc.write': {
      label: 'gds.wcc.write',
      documentation:
        'The WCC algorithm finds sets of connected nodes in an undirected graph, where all nodes in the same set form a connected component.',
      parameters: [
        {
          label: 'graphName',
          documentation: 'graphName :: STRING?',
        },
        {
          label: 'configuration',
          documentation: 'configuration = {} :: MAP?',
        },
      ],
    },
    'gds.wcc.write.estimate': {
      label: 'gds.wcc.write.estimate',
      documentation:
        'Returns an estimation of the memory consumption for that procedure.',
      parameters: [
        {
          label: 'graphNameOrConfiguration',
          documentation: 'graphNameOrConfiguration :: ANY?',
        },
        {
          label: 'algoConfiguration',
          documentation: 'algoConfiguration :: MAP?',
        },
      ],
    },
    'tx.getMetaData': {
      label: 'tx.getMetaData',
      documentation: 'Provides attached transaction metadata.',
      parameters: [],
    },
    'tx.setMetaData': {
      label: 'tx.setMetaData',
      documentation:
        'Attaches a map of data to the transaction. The data will be printed when listing queries, and inserted into the query log.',
      parameters: [
        {
          label: 'data',
          documentation: 'data :: MAP?',
        },
      ],
    },
  },
  labels: ['Movie', 'Person'],
  relationshipTypes: [
    'ACTED_IN',
    'DIRECTED',
    'FOLLOWS',
    'PRODUCED',
    'REVIEWED',
    'WROTE',
  ],
  propertyKeys: [
    'born',
    'data',
    'id',
    'name',
    'nodes',
    'rating',
    'relationships',
    'released',
    'roles',
    'style',
    'summary',
    'tagline',
    'title',
    'visualisation',
  ],
  parameters: {
    param1: {
      property: 'value',
      speed: 123.4,
    },
    favColor: 'green',
    myParam: 1337,
  },
  databaseNames: ['neo4j', 'oskar', 'system'],
  aliasNames: ['alias2', 'testalias'],
};
